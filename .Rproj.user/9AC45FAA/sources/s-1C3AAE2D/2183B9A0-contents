Steps for adding an addition alarm function:

Unfortunately, there's not a super-simple way for adding an additional alarm function to the mix. Here are the stpes that I think need to be done (as of 20 Mar 2020):

Version 1: Easy Mode

1. Give your alarm function a good name. In particular, the prefix on the name is used to categorize the type of alarm function that it is. Currently recognized classes are "scan_" and "parallel_". "scan_"-type functions are ones that use overlapping spatial zones, while "parallel_" type functions apply an alarm function to each spatial region independently. Yes, all a scan_ type function with max_k = 1 is equivalent to the parallel_ type functions, but it's often convenient to consider them seperately.

2. Have the new alarm function return useful outputs. If it is a scan_ type function, it should return an object of class scanstatistics, preferably matching the results from scan_eb_poisson or scan_eb_poisson_fast. If it is a parallel_ type function, it should return a data.frame, where the columns are spatial regions, and the rows are time periods (oldest to newest).

3. Modify standardized_alarm_functions:
  a. Add the alarm function name either to "requires_zones", "requires_key", or "parallel_type" vectors - these help the function know which arguments are required and give informative error messages.
  b. Find the big if/else block in the "Apply scanstatistics" section. If your function inputs match that of one of the functions already listed, modify one of the if/else-if sections to include your function there. If your function inputs do not match any already present, add an additional block to the function.

4. That should be it! If your function output matches the expected form, it should be able to work easily.

Version 2: Hard Mode

1. Give your alarm function whatever name you want. Invent a whole new class of alarm functions for you to use. Maybe it'd be useful to have an alarm function that considers all of the spatial regions as a single unit, so you call your alarm function serial_shewart_gaussian

2. Have your new alarm function return a totally crazy output form - some sort of list of list, with no rhyme or reason. While you're add it, make it take some very crazy input values as well, just to keep things interesting.

3. In loop_alarm_functions.R/"Prep steps for scan-type alarm functions",  extend that if block, e.g., } else if (alarm_type == "serial") {
  whatever_input_prep_needs_to_happen_here
}

4. If necessary, you might have to modify the function call to cached_standardized_alarms_mc, to pass in your additional input arguments, if you can't pass them through the ... argument.
  a. If you do modify that function call, you'll need to modify the input arguments of standardized_alarms_multicol and within that function, you'll need to modify the call to standardize_alarm_functions.

5. Modify standardize_alarm_functions, following the guide in step 3 in the Easy Mode version.

6. You'll also need to modify collapse_alarm_functions to deal with your crazy crazy output format. This function needs to be able to take a list of scan results and collapse them down into a single reasonable scan result. See collapse_scan_bayes for an example of what this might look like.
