% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/loop_extract_yhat.R
\name{loop_extract_yhat}
\alias{loop_extract_yhat}
\title{Predict Values From a Series of Model Fits}
\usage{
loop_extract_yhat(
  space_coord,
  time_coord,
  list_of_model_fits,
  list_of_model_data,
  yhat_extractor_name = "extract",
  use_surveillance_residuals = TRUE,
  path_to_model = NULL,
  use_cache = FALSE,
  force = FALSE,
  verbose = interactive(),
  n_samples = NULL,
  extra_extractor_args = list()
)
}
\arguments{
\item{space_coord}{A gridcoord object
(\code{\link[gridcoord]{gc_gridcoord}}) describing the spatial area that is
covered by \code{list_of_model_fits} and \code{list_of_model_data}.}

\item{time_coord}{A gridcoord object (\code{\link[gridcoord]{gc_gridcoord}}) describing the
temporal area that is covered by \code{list_of_model_fits} and \code{list_of_model_data}. This coordinate
must be ordered, with the first row in the data.frame corresponding to the earliest time
period and the last row corresponding to the most recent.}

\item{list_of_model_fits}{Either a list or a \link[gridcoord]{gridlist}, generated by
\code{\link{loop_model}}. Each entry of \code{list_of_model_fits} must be a model fit object, such
as that generated by \code{lm} or \code{glm}. These entries must either be in a single list organized by
time, or a \link[gridcoord]{gridlist} organized by both space and time.}

\item{list_of_model_data}{Either a list or a \link[gridcoord]{gridlist}, generated by
\code{\link{loop_model}}. Each entry of \code{list_of_model_data} must be a data.frame with columns
corresponding to \code{space_coord}, \code{time_coord}, and a column containing the primary outcome of
interest. These entries must either be in a single list organized by time, or a
\link[gridcoord]{gridlist} organized by both space and time.}

\item{yhat_extractor_name}{How should predicted values be extracted from the model fits. Valid
values are "extract" (the default), "sample", or a user-supplied custom function. See section
"Extrator Functions" for more details.}

\item{use_surveillance_residuals}{Should the function return surveillance predicted values
(\code{TRUE}) or ordinary predicted values (\code{FALSE})}

\item{path_to_model}{The path to the model function, or the function itself, that was  used to
calculate the model fits in \code{\link{loop_model}}. This parameter is used only to
determine where cached results should be saved, if caching is being used.}

\item{use_cache}{Should the results from this function be saved (cached), so that the results can
be quickly loaded without having to re-run the calculation? Likely only to save time when
sampling from a complex Monte-Carlo type model.}

\item{force}{If previous results have been cached, should the function be forced to redo the
calculations? \code{force} can be a single logical value or a vector indicating specific time
points to be re-calculated.}

\item{verbose}{Should updates be printed to the console?}

\item{n_samples}{If \code{yhat_extractor_name = 'sample'}, how many samples should be taken?}

\item{extra_extractor_args}{A named list containing additional parameters to supply to the
extractor function. See section "Extrator Functions" for more details.}
}
\value{
A hierarchically organized list, where each entry is a data.frame with columns
corresponding to \code{space_coord}, \code{time_coord}, and one or more columns of predicted values.
These entries will either be in a single list organized by time, or a a
\link[gridcoord]{gridlist} organized by both space and time,  depending on the format of
\code{list_of_model_data} and \code{list_of_model_fits}.
}
\description{
Given a set of model fits, extract predicted values ('yhat') from the model objects.
}
\section{Surveillance Residuals}{
 In contrast to ordinary residuals, which are reported for all
data points, surveillance residuals are only reported for points that were not used to
calculate the model fit. For a surveillance model run at time \emph{t}, data points \emph{0}-\emph{t-1} are
typically used to fit the model, but predictions are made on data points \emph{0}-\emph{t}. If
\code{use_surveillance_residuals = FALSE}, then the model fit at time \emph{t} will be used to report all
the predicted values. If \code{use_surveillance_residuals = TRUE}, then the model fit at time \emph{t}
will used to report only the predicted values at time \emph{t}, the model fit at time \emph{t-1} will be
used to report the predicted values time \emph{t-1}, etc.
}

\section{Using \code{loop_extract_yhat} with \code{\link{loop_model}}}{

\code{loop_extract_yhat} is designed
to used in conjunction with \code{\link{loop_model}}. The coordinate arguments, \code{space_coord}
and \code{time_coord} should be identical to those used by \code{\link{loop_model}}.
\code{list_of_model_fits} and \code{list_of_model_data} should be the first and second components of the
hierarchical list returned by \code{\link{loop_model}}. \code{path_to_model} is optional for
\code{loop_extract_yhat}, but to most clearly organize the cached information, it should match the
value used in \code{\link{loop_model}}.
}

\section{Extractor Functions}{

There are currently three different ways to predict values from the
model fits using \code{loop_extract_yhat}, depending on the value of the \code{yhat_extactor_name}
argument. If \code{yhat_extractor_name = "extract"}, then a single point estimate of the predicted
values will be returned. Currently allowed fits for this option are \code{\link[stats]{lm}},
\code{\link[stats]{glm}}, \code{\link[INLA]{inla}}, and \code{\link[forecast]{Arima}}.

If \code{yhat_extractor_name = "sample"}, then a distribution of possible values will be calculated,
using the \code{\link[arm]{sim}} method from the \code{arm} package. The number of samples is
controlled by the \code{n_samples} parameter. Currently allowed fits for this options are
\code{\link[stats]{lm}}, \code{\link[stats]{glm}} and \code{\link[INLA]{inla}}.

If neither of the two built in options are sufficient, a custom function can be passed as the
argument to \code{yhat_extractor_name}. This function must take as its first four arguments
\code{space_coord}, \code{time_coord}, \code{fit}, and \code{data}, and it must return a data.frame with columns
corresponding to \code{space_coord}, \code{time_coord}, and one or more columns of predicted values.
Unlike the custom functions in \code{\link{loop_model}}, these function \emph{cannot} return any
additional information. Use the \code{\link{loop_over}} function if you need to compute
additional values for each model fit.
\subsection{Additional arguments:}{

The \code{\link[forecast]{Arima}} "extract" method and many custom extraction functions require
additional arguments. These can be passed from \code{loop_extract_yhat} to the extractor function by
including them as entries in the \code{extra_model_args} parameter. All the components in
\code{extra_model_args} will be passed through unchanged to the extractor function, \strong{unless} any
of the components are lists or \link[gridcoord:gridlist]{gridlists} with the same names as the
\code{list_of_model_data} argument. In this case, each time the extrctor function is run,
\code{loop_extract_yhat} will pass a different element of the component into the extractor function.
}
}

\section{Caching overview}{

Caching in the \code{statsurv} is done using the \code{\link[simplecache:cache_wrap]{simplecache}}
package. The first time you run this function with \code{use_cache = TRUE}, it will create a
sub-directory based on the value of \code{path_to_model}, where it will save the returned values
from every iteration. The next time you run the function, \code{simplecache} will check if the
function inputs are identical to a previous run. If so, \code{simplecache} will load the model
output from disc instead of re-fitting the model.

Determing when to use the cache is not always straightforward, so it is possible that
\code{simplecache} will make a mistake sometimes and use a cached value when it should not. The
\code{force} argument to allows you to override the default behavior, and force the function to
re-calculate the results from scratch.

Some functions take an additional argument \code{save_environments} that controls how fit objects
and formulas as saved. These objects often capture their entire environment when they are
created, which can cause the saved objects to be extremely large. Setting
\code{save_environments = FALSE} removes the captured environments from the model fits when
saving them.
}

\examples{
## Not run:
# Define our coordinates and generate data
space_coord <- data.frame(space_label = c("space1", "space2"), stringsAsFactors = FALSE)
time_coord <- data.frame(time_label = paste0("t", 1:10),
                         time = 1:10,
                         fin_time = 2:11,
                         stringsAsFactors = FALSE)
data_for_model <- expand.grid(space_label = space_coord[[1]],
                              time_label = time_coord[[1]],
                              stringsAsFactors = FALSE)
data_for_model$x <- runif(nrow(data_for_model), max = 15)
data_for_model$y <- data_for_model$x * 1.05 + rnorm(nrow(data_for_model))

# Define our model function
simple_lm_func <- function(space_coord, time_coord, data_for_model) {
  fit <- lm(y ~ x,
            data = data_for_model)
return(list(fit = fit,
              data = data_for_model))
}

# Loop the model
all_fits_and_data <- loop_model(space_coord, time_coord, data_for_model, "y",
                                simple_lm_func, min_train = 5, use_cache = FALSE)
all_fits <- all_fits_and_data[[1]]
all_data <- all_fits_and_data[[2]]

# Calculate predicted values for each model fit
loop_extract_yhat(space_coord, time_coord, all_fits, all_data,
                  yhat_extractor_name = "extract", use_cache = FALSE)

## End (Not run)
}
\seealso{
\code{\link{extract_yhat}} and \code{\link{sample_yhat}} for details on how the
extractor functions work.

Other looping functions: 
\code{\link{loop_alarm_function}()},
\code{\link{loop_model}()},
\code{\link{loop_over}()}
}
\concept{looping functions}
