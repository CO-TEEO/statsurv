#' @title Predict Values From a Series of Model Fits
#'
#' @description Given a set of model fits, extract predicted values ('yhat') from the model objects.
#'
#' @param space_coord A gridcoord object
#'   (\code{\link[gridcoord]{gc_gridcoord}}) describing the spatial area that is
#'   covered by `list_of_model_fits` and `list_of_model_data`.
#' @param time_coord A gridcoord object (\code{\link[gridcoord]{gc_gridcoord}}) describing the
#'   temporal area that is covered by `list_of_model_fits` and `list_of_model_data`. This coordinate
#'   must be ordered, with the first row in the data.frame corresponding to the earliest time
#'   period and the last row corresponding to the most recent.
#' @param list_of_model_fits Either a list or a \link[gridcoord]{gridlist}, generated by
#'   \code{\link{loop_model}}. Each entry of `list_of_model_fits` must be a model fit object, such
#'   as that generated by `lm` or `glm`. These entries must either be in a single list organized by
#'   time, or a \link[gridcoord]{gridlist} organized by both space and time.
#' @param list_of_model_data Either a list or a \link[gridcoord]{gridlist}, generated by
#'   \code{\link{loop_model}}. Each entry of `list_of_model_data` must be a data.frame with columns
#'   corresponding to `space_coord`, `time_coord`, and a column containing the primary outcome of
#'   interest. These entries must either be in a single list organized by time, or a
#'   \link[gridcoord]{gridlist} organized by both space and time.
#' @param yhat_extractor_name How should predicted values be extracted from the model fits. Valid
#'   values are "extract" (the default), "sample", or a user-supplied custom function. See section
#'   "Extrator Functions" for more details.
#' @param use_surveillance_residuals Should the function return surveillance predicted values
#'   (`TRUE`) or ordinary predicted values (`FALSE`)
#' @param path_to_model The path to the model function, or the function itself, that was  used to
#'   calculate the model fits in \code{\link{loop_model}}. This parameter is used only to
#'   determine where cached results should be saved, if caching is being used.
#' @param use_cache Should the results from this function be saved (cached), so that the results can
#'   be quickly loaded without having to re-run the calculation? Likely only to save time when
#'   sampling from a complex Monte-Carlo type model.
#' @param force If previous results have been cached, should the function be forced to redo the
#'   calculations? \code{force} can be a single logical value or a vector indicating specific time
#'   points to be re-calculated.
#' @param verbose Should updates be printed to the console?
#' @param n_samples If `yhat_extractor_name = 'sample'`, how many samples should be taken?
#' @param extra_extractor_args A named list containing additional parameters to supply to the
#'   extractor function. See section "Extrator Functions" for more details.
#'
#' @return A hierarchically organized list, where each entry is a data.frame with columns
#'   corresponding to `space_coord`, `time_coord`, and one or more columns of predicted values.
#'   These entries will either be in a single list organized by time, or a a
#'   \link[gridcoord]{gridlist} organized by both space and time,  depending on the format of
#'   `list_of_model_data` and `list_of_model_fits`.
#'
#' @section Surveillance Residuals: In contrast to ordinary residuals, which are reported for all
#'   data points, surveillance residuals are only reported for points that were not used to
#'   calculate the model fit. For a surveillance model run at time *t*, data points *0*-*t-1* are
#'   typically used to fit the model, but predictions are made on data points *0*-*t*. If
#'   `use_surveillance_residuals = FALSE`, then the model fit at time *t* will be used to report all
#'   the predicted values. If `use_surveillance_residuals = TRUE`, then the model fit at time *t*
#'   will used to report only the predicted values at time *t*, the model fit at time *t-1* will be
#'   used to report the predicted values time *t-1*, etc.
#'
#' @section Using `loop_extract_yhat` with \code{\link{loop_model}}:
#'   `loop_extract_yhat` is designed
#'   to used in conjunction with \code{\link{loop_model}}. The coordinate arguments, `space_coord`
#'   and `time_coord` should be identical to those used by \code{\link{loop_model}}.
#'   `list_of_model_fits` and `list_of_model_data` should be the first and second components of the
#'   hierarchical list returned by \code{\link{loop_model}}. `path_to_model` is optional for
#'   `loop_extract_yhat`, but to most clearly organize the cached information, it should match the
#'   value used in \code{\link{loop_model}}.
#'
#' @section Extractor Functions:
#'   There are currently three different ways to predict values from the
#'   model fits using `loop_extract_yhat`, depending on the value of the `yhat_extactor_name`
#'   argument. If `yhat_extractor_name = "extract"`, then a single point estimate of the predicted
#'   values will be returned. Currently allowed fits for this option are \code{\link[stats]{lm}},
#'   \code{\link[stats]{glm}}, \code{\link[INLA]{inla}}, and \code{\link[forecast]{Arima}}.
#'
#'   If `yhat_extractor_name = "sample"`, then a distribution of possible values will be calculated,
#'   using the \code{\link[arm]{sim}} method from the `arm` package. The number of samples is
#'   controlled by the `n_samples` parameter. Currently allowed fits for this options are
#'   \code{\link[stats]{lm}}, \code{\link[stats]{glm}} and \code{\link[INLA]{inla}}.
#'
#'   If neither of the two built in options are sufficient, a custom function can be passed as the
#'   argument to `yhat_extractor_name`. This function must take as its first four arguments
#'   `space_coord`, `time_coord`, `fit`, and `data`, and it must return a data.frame with columns
#'   corresponding to `space_coord`, `time_coord`, and one or more columns of predicted values.
#'   Unlike the custom functions in \code{\link{loop_model}}, these function *cannot* return any
#'   additional information. Use the \code{\link{loop_over}} function if you need to compute
#'   additional values for each model fit.
#'
#'   ## Additional arguments:
#'   The \code{\link[forecast]{Arima}} "extract" method and many custom extraction functions require
#'   additional arguments. These can be passed from `loop_extract_yhat` to the extractor function by
#'   including them as entries in the `extra_model_args` parameter. All the components in
#'   `extra_model_args` will be passed through unchanged to the extractor function, **unless** any
#'   of the components are lists or \link[gridcoord:gridlist]{gridlists} with the same names as the
#'   `list_of_model_data` argument. In this case, each time the extrctor function is run,
#'   `loop_extract_yhat` will pass a different element of the component into the extractor function.
#'
#' @inheritSection loop_model Caching overview
#' @examples
#' ## Not run:
#' # Define our coordinates and generate data
#' space_coord <- data.frame(space_label = c("space1", "space2"), stringsAsFactors = FALSE)
#' time_coord <- data.frame(time_label = paste0("t", 1:10),
#'                          time = 1:10,
#'                          fin_time = 2:11,
#'                          stringsAsFactors = FALSE)
#' data_for_model <- expand.grid(space_label = space_coord[[1]],
#'                               time_label = time_coord[[1]],
#'                               stringsAsFactors = FALSE)
#' data_for_model$x <- runif(nrow(data_for_model), max = 15)
#' data_for_model$y <- data_for_model$x * 1.05 + rnorm(nrow(data_for_model))
#'
#' # Define our model function
#' simple_lm_func <- function(space_coord, time_coord, data_for_model) {
#'   fit <- lm(y ~ x,
#'             data = data_for_model)
#' return(list(fit = fit,
#'               data = data_for_model))
#' }
#'
#' # Loop the model
#' all_fits_and_data <- loop_model(space_coord, time_coord, data_for_model, "y",
#'                                 simple_lm_func, min_train = 5, use_cache = FALSE)
#' all_fits <- all_fits_and_data[[1]]
#' all_data <- all_fits_and_data[[2]]
#'
#' # Calculate predicted values for each model fit
#' loop_extract_yhat(space_coord, time_coord, all_fits, all_data,
#'                   yhat_extractor_name = "extract", use_cache = FALSE)
#'
#' ## End (Not run)
#' @family looping functions
#' @seealso \code{\link{extract_yhat}} and \code{\link{sample_yhat}} for details on how the
#'   extractor functions work.
#' @export
#' @md
loop_extract_yhat <- function(space_coord,
                              time_coord,
                              list_of_model_fits,
                              list_of_model_data,
                              yhat_extractor_name = "extract",
                              use_surveillance_residuals = TRUE,
                              path_to_model = NULL,
                              use_cache = FALSE,
                              force = FALSE,
                              verbose = interactive(),
                              n_samples = NULL,
                              extra_extractor_args = list()) {

  ### Helper Functions ----


  ### Argument checks ----
  space_coord <- gridcoord::gc_gridcoord(space_coord)
  time_coord <- gridcoord::gc_gridcoord(time_coord)
  space_name <- gridcoord::gc_get_name(space_coord)
  time_name <- gridcoord::gc_get_name(time_coord)
  check_type(list_of_model_fits, c("list", "gridlist"))
  check_type(list_of_model_data, c("list", "gridlist"))
  check_scalar_type(use_surveillance_residuals, "logical")
  check_scalar_type(yhat_extractor_name, c("character", "function"))
  check_type(path_to_model, c("NULL", "character", "function"))
  if (is.character(path_to_model)) {
    check_scalar(path_to_model)
  }
  # force passed through to the cache
  check_scalar_type(verbose, "logical")



  ### Check if we need to work spatially ----
  # Will be done if list_of_model_fits & list_of_model_data are already gridlists
  if (is_type(list_of_model_fits, "gridlist")) {
    check_type(list_of_model_data, "gridlist")
    space_coord <- space_coord_split(space_coord)
    total_space <- nrow(list_of_model_fits)
  } else {
    total_space <- 1
  }

  ### Load the extractor function ----
  if (is.function(yhat_extractor_name)) {
    name_of_extractor <- fix_up_path(deparse(substitute(yhat_extractor_name)))
  } else {
    name_of_extractor <- tools::file_path_sans_ext(basename(yhat_extractor_name))
  }
  yhat_extractor_func <- parse_yhat_extractor(yhat_extractor_name)

  ### Set up caching ----

  cache_dir <- calc_cache_dir(use_cache,
                              top_level = "cache_yhat",
                              ifelse(is.character(path_to_model),
                                     path_to_model,
                                     deparse(substitute(path_to_model))),
                              name_of_extractor)
  # There shouldn't be any environments captured in the results
  # but set save_environments = TRUE just to be on the safe side.
  cached_yhat_func <- suppressWarnings(
    simplecache::cache_wrap(yhat_extractor_func,
                            cache_dir = cache_dir,
                            hash_in_name = FALSE,
                            save_environments = TRUE)
    )

  force <- parse_force(force, time_coord)

  ### Create progress bar
  progress_bar <- dot_progress_functional(total = total_space,
                                          dot_every = 1,
                                          number_every = 5,
                                          title = "Extracting predicted values",
                                          verbose = verbose)


  ### Pad extra arguments to extractor ----
  n_iter <- length(list_of_model_fits)
  if (is.character(yhat_extractor_name) && yhat_extractor_name == "sample" &&
      !"n_samples" %in% names(extra_extractor_args)) {
    if (is.null(n_samples)) {
      n_samples <- 10
    }
    extra_extractor_args[["n_samples"]] <- n_samples
  }
  list_args <- pad_args(extra_extractor_args,
                        reference = list_of_model_fits)

  ### Loop over spatial regions ----
  if (is_type(list_of_model_data, "gridlist")) {
    return_accum <- list()
    for (space_ind in seq_len(nrow(list_of_model_data))) {
      curr_space_coord <- space_coord[[space_ind]]
      curr_space_name <- gridcoord::gc_get_labels(curr_space_coord)[[1]]


      curr_fits <- extract_gcl_row(list_of_model_fits, space_ind)
      curr_data <- extract_gcl_row(list_of_model_data, space_ind)
      curr_extra_args <-  extract_gcl_row(list_args, space_ind)

      return_accum[[curr_space_name]] <-
        loop_extract_yhat_int(curr_space_coord, time_coord,
                              curr_fits, curr_data,
                              yhat_extractor_func = cached_yhat_func,
                              force = force,
                              use_surveillance_residuals = use_surveillance_residuals,
                              list_of_extra_args = curr_extra_args,
                              progress_bar = progress_bar)
    }
    # currently organized as just a list of lists
    res <- gridcoord::gcl_gridlist(return_accum,
                                   do.call(rbind, space_coord),
                                   time_coord)
    return(res)
  } else {
    res <- loop_extract_yhat_int(space_coord, time_coord,
                                 list_of_model_fits, list_of_model_data,
                                 yhat_extractor_func = cached_yhat_func,
                                 force = force,
                                 use_surveillance_residuals = use_surveillance_residuals,
                                 list_of_extra_args = list_args,
                                 progress_bar = progress_bar)
    return(res)
  }

}

loop_extract_yhat_int <- function(space_coord,
                                  time_coord,
                                  list_of_model_fits,
                                  list_of_model_data,
                                  yhat_extractor_func,
                                  force,
                                  use_surveillance_residuals,
                                  list_of_extra_args,
                                  progress_bar) {


  ### Validate fits and data ----
  # Has to be be done after splitting the data spatially
  validate_model_list(list_of_model_fits, time_coord)
  validate_model_list(list_of_model_data, time_coord)
  if (length(list_of_model_fits) != length(list_of_model_data)) {
    stop_subclass("list_of_model_fits and list_of_model_data must be the same length",
                  .subclass = "error_bad_arg_value")
  }
  if (!identical(names(list_of_model_fits), names(list_of_model_data))) {
    stop_subclass("The names of list_of_model_fits and list_of_model_data must be identical",
                  .subclass = "error_bad_arg_value")
  }

  total_time <- sum(!is_singular_na(list_of_model_fits))

  ### Loop over all the input fits ----
  n_fits <- length(list_of_model_fits)
  list_of_yhats <- list()

  for (ind in seq_len(n_fits)) {
    fit <- list_of_model_fits[[ind]]
    if (identical(fit, NA)) {
      next
    }
    data <- list_of_model_data[[ind]]
    curr_name <- names(list_of_model_fits)[[ind]]
    cache_name <- build_cache_name(curr_name, space_coord)
    validate_data_for_yhat(space_coord, time_coord, data, curr_name)

    yhat <- do.call.with.dots(yhat_extractor_func,
                              space_coord,
                              time_coord,
                              fit,
                              data,
                              list_of_args = list_of_extra_args[[ind]],
                              .name_prefix = cache_name,
                              .force = force[[curr_name]])

    yhat <- dplyr::arrange(yhat,
                           gridcoord::gc_get_match(yhat, space_coord),
                           gridcoord::gc_get_match(yhat, time_coord)) #Needs work to sort by
    # Accumulate results, update progress
    list_of_yhats[[curr_name]] <- yhat
    progress_bar(step = 1 / total_time)
  }

  ### Convert to surveillance ----
  if (use_surveillance_residuals) {
    list_of_yhats <- convert_to_surveillance(space_coord, time_coord, list_of_yhats)
  }

  # Pad with NAs
  padded_yhats <- pad_with_nas(list_of_yhats, coord = time_coord)

  return(padded_yhats)
}

