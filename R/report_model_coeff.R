#' @title Return information about a model or its coefficients
#'
#' @description `report_model_coeff` and `report_model_summary` are simple wrappers around the
#'   functions \code{\link[broom]{tidy}} and \code{\link[broom]{glance}} from the broom package that
#'   can also report information from \code{\link[INLA]{inla}} models.
#'
#' @param fit The model fit object. The model fit can be generated by INLA or by any model function
#'   recognized by the \code{\link[broom]{broom}} package.
#' @param include_random In `report_model_coeff`, for INLA models only, should random effects be
#'   included in the returned data.frame? If FALSE, only fixed effects and model hyper-parameters
#'   will be returned.
#'
#' @return For `report_model_coeff`, a \code{\link[tibble]{tibble}} containing estimates and
#'   standard errors of the coefficients in `fit`. For `report_model_summary`, a 1-row summary
#'   tibble containing information of goodness of fit, p-values, or model convergence.
#' @seealso \code{\link[broom]{tidy}}, \code{\link[broom]{glance}}
#' @md
#' @examples
#' x <- rnorm(20, mean = 0, sd = 3)
#' y <- 1.3 + 2.5 * x + rnorm(20, sd = 1)
#' df <- data.frame(x = x, y = y)
#'
#'
#' fit_lm <- lm(y ~ x, data = df)
#' report_model_coeff(fit_lm)
#' report_model_summary(fit_lm)
#'
#' \dontrun{
#'
#' fit_inla <- INLA::inla(y ~ x, data = df)
#' report_model_coeff(fit_inla)
#' report_model_summary(fit_inla)
#' }
#'
#' @name report_model_
NULL

#' @export
#' @rdname report_model_
report_model_coeff <- function(fit, include_random = FALSE) {
  # By and large we're going to use broom::tidy for this, but adding in our own methods for
  # INLA models
  if (is_type(fit, "inla")) {
    df <- tidy_inla(fit, include_random)
  } else {
    df <- broom::tidy(fit)
  }
  return(df)
}

#' @export
#' @rdname report_model_
report_model_summary <- function(fit) {
  if (is_type(fit, "inla")) {
    df <- glance_inla(fit)
  } else {
    df <- broom::glance(fit)
  }
  return(df)
}

tidy_inla <- function(fit, include_random = FALSE) {
  # We want the columns: term, estimate, std. error, statistic, p.value
  # I'm not sure what most of these are. I guess they're just t-statistics.
  # For p. values, we don't have to assume a normal distribution.

  # For our first approach, we just combine the summary_fixed and summary_hyper
  null_df <- data.frame(mean = c(1), sd = c(1))[c(), ]
  fixed_df <- rbind(null_df, fit$summary.fixed[, c("mean", "sd")])
  hyper_df <- rbind(null_df,
                    fit$summary.hyperpar[, c("mean", "sd")])
  fixed_df$type <- rep("fixed", nrow(fixed_df))
  hyper_df$type <- rep("hyper", nrow(hyper_df))

  fixed_df$term <- rownames(fixed_df)
  hyper_df$term <- rownames(hyper_df)

  summary_df <- rbind(fixed_df, hyper_df)
  all_marginals <- c(fit$marginals.fixed, fit$marginals.hyperpar)

  if (include_random) {
    random_est <- list()
    null_random_df <- data.frame(group = c(1), mean = c(1), sd = c(1))[c(), ]
    for (name in names(fit$summary.random)) {
      q_df <- fit$summary.random[[name]]
      col1 <- names(q_df)[[1]]
      q_df <- q_df[, c(col1, "mean", "sd")]
      q_df$group <- name
      random_est[[name]] <- q_df
    }
    random_df <- do.call(rbind, random_est)
    random_df$term <- random_df[[1]]
    random_df <- rbind(null_random_df, random_df[, -1])
    random_df$type <- rep("random", nrow(random_df))
    random_marginals <- unlist(fit$marginals.random, recursive = FALSE)

    summary_df$group <- NA
    summary_df <- rbind(summary_df, random_df)
    all_marginals <- c(all_marginals, random_marginals)
  }


  summary_df$statistic <- summary_df$mean / summary_df$sd


  pval <- sapply(all_marginals, INLA::inla.pmarginal, q = 0)

  summary_df$p.value <- ifelse(summary_df$mean < 0, 1 - pval, pval)
  summary_df$estimate <- summary_df$mean
  summary_df$std.error <- summary_df$sd

  rownames(summary_df) <- NULL
  wanted_col <- c("term", "estimate", "std.error", "statistic", "p.value", "type")
  if (include_random) {
    wanted_col <- c(wanted_col, "group")
  }
  summary_df <- summary_df[, wanted_col, drop = FALSE] %>%
    tibble::as_tibble()
  return(summary_df)
}

glance_inla <- function(fit) {
  glance_list <- list(cpu.time = fit$cpu.used["Total"],
                      deviance = fit$dic$deviance.mean,
                      logLik = fit$mlik[nrow(fit$mlik), 1],
                      DIC = fit$dic$dic,
                      DIC.sat = fit$dic$dic.sat,
                      WAIC = fit$waic$waic,
                      cpo.failures =  sum(is.na(fit$cpo$failure)) +
                        sum(fit$cpo$failure, na.rm = TRUE),
                      cpo.logsum = sum(log(fit$cpo$cpo), na.rm = TRUE),
                      n.eff.param = fit$neffp[1, 1])
  m <- sapply(glance_list, is.null)
  glance_list[m] <- NA

  glance_df <- tibble::as_tibble(glance_list)
  return(glance_df)
}
