#' @title Apply an alarm function to the output of `loop_model` and `loop_extract_yhat`
#'
#' @description Given a set of observations and a set of baseline predictions, apply an alarm
#'   function sequentially in time.
#'
#' @param space_coord A gridcoord object
#'   (\code{\link[gridcoord]{gc_gridcoord}}) describing the spatial area that is
#'   covered by `list_of_yhats` and `list_of_model_data`
#' @param time_coord A gridcoord object (\code{\link[gridcoord]{gc_gridcoord}})
#'   describing the temporal area that is covered by `list_of_yhats` and `list_of_model_data`. This
#'   coordinate must be ordered, with the first entries in the coordinate corresponding to the
#'   earliest time periods and the last entries corresponding to the most recent.
#' @param list_of_yhats Either a list or a \link[gridcoord]{gridlist} generated by
#'   \code{\link{loop_extract_yhat}}. Each entry of the list must be a data.frame with columns
#'   corresponding to `space_coord`, `time_coord`, and one or more columns of predicted values.
#'   These entries must either be in a single list organized by time, or a
#'   \link[gridcoord]{gridlist} organized by both space and time.
#' @param list_of_model_data Either a list or a \link[gridcoord]{gridlist}, generated by
#'   \code{\link{loop_model}}. Each entry of `list_of_model_data` must be a data.frame with columns
#'   corresponding to `space_coord`, `time_coord`, and a column containing the primary outcome of
#'   interest. These entries must either be in a single list organized by time, or a
#'   \link[gridcoord]{gridlist} organized by both space and time.
#' @param outcome_col The name of the column in the data.frames in \code{list_of_model_data}
#'   containing the primary outcome (e.g., the number of elevated cases).
#' @param max_k The maximum number of locations to be included in any one zone when constructing
#'   spatial zones for scan-type alarm functions,
#' @param extra_alarm_args A named list containing additional parameters to supply to the
#'   alarm function. Consult the documentation for the individual alarm functions for details.
#' @param use_cache Should the results from this function be saved (cached), so that the results can
#'   be quickly loaded without having to re-run the calculation? Likely only to save time when
#'   applying a scan-type alarm function and both `max_k` and `n_mcsim` are large.
#' @inheritParams loop_extract_yhat
#' @inheritParams standardized_alarm_functions
#'
#' @details `loop_alarm_function` repeatedly applies an alarm function to a set of observations and
#'   baseline predictions. The alarm function cannot be supplied by the user, and must be one of the
#'   functions built into \code{\link{standardized_alarm_functions}}.
#'
#' All of the supported alarm functions support observations in multiple spatial and temporal
#' regions. If either `list_of_yhats` or `list_of_model_data` are
#' \link[gridcoord:gridlist]{gridlists}, they will be collapsed down to a single list organized by
#' time before applying the alarm function.
#'
#' Parallel-type alarms functions, such as \code{\link{parallel_cusum_poisson}} consider each
#' spatial region independently, and calculate 1 alarm statistic for each region. Scan-type alarm
#' functions, such as \code{\link[scanstatistics]{scan_eb_poisson}} aggregate spatial regions into
#' *zones*, and calculate an alarm statistic for each zone. The creation of zones from spatial
#' regions is done using a k-nearest neighbors approach. This means that zones are constructed by
#' starting with each region individually, and sequentially adding its first-nearest-neighbor, then
#' its second-nearest neighbor, and so on up to a maximum size of `max_k`.
#'
#' @inheritSection standardized_alarm_functions Supported Alarm Functions
#' @inheritSection loop_model Caching overview
#'
#' @section Using `loop_alarm_function` with \code{\link{loop_model}} and \code{\link{loop_extract_yhat}}:
#'   `loop_alarm_function` is designed to used in conjunction with \code{\link{loop_model}} and
#'   \code{\link{loop_extract_yhat}}. The coordinate arguments, `space_coord` and `time_coord`
#'   should be identical to those used by the other two functions. `list_of_model_data` should be
#'   generated by  \code{\link{loop_model}}, and `list_of_yhats` should be generated by
#'   \code{\link{loop_extract_yhat}}.  `path_to_model` is optional for `loop_alarm_function`, but to
#'   most clearly organize the cached information, it should match the value used in the other two
#'   functions.
#'
#' @family looping functions
#' @seealso \code{\link{standardized_alarm_functions}} for more information about the available
#'   alarm functions; \code{\link{space_coord_to_zones}} for generating zones manually.
#' @return A list organized by time, where each entry is the result from the individual alarm
#'   function. For the alarm functions that begin "parallel_", each entry is a matrix where the
#'   columns correspond to spatial region and rows correspond to time period; for all other alarm
#'   functions entries are objects of class `scanstatistics`. All results have an attribute
#'   "alarm_type" describing whether they are a scan-type alarm function or a parallel-type alarm
#'   function.
#'
#'   All returned `scanstatistics` objects have been slightly standardized:
#'   \itemize{
#'       \item{The returned object now contains the component `zone_info` containing information
#'       about the spatio-temporal zones}
#'       \item{The returned object always contains the component `observed`, giving the likelihood
#'       of an outbreak in each spatio-temporal zone}
#'       \item{The components `observe`, `MLC`, and `replicates` (if applicable) always contain the
#'       column `action_level`. The higher the value of this column, the greater the likelihood of
#'       an outbreak. This column is identical to `score` for all scan-type alarm functions except
#'       for \code{\link[scanstatistics]{scan_bayes_negbin}}, where it is equal to `log_posterior`}
#'   }
#' @export
#' @md
#'
#' @examples
#' library("scanstatistics")
#' library("magrittr")
#' library("gridcoord")
#' data(NM_popcas)
#' NM_popcas$county <- as.character(NM_popcas$county)
#' NM_popcas$date_label <- as.character(NM_popcas$year)
#'
#' nm_county_fips_2010 <- statsurv::nm_county_fips_2010
#' nm_county_fips_2010$county <- gsub(" ", "", tolower(nm_county_fips_2010$county_name))
#' nm_county_fips_2010 <- nm_county_fips_2010[nm_county_fips_2010$county != "cibola", ]
#' nm_county_fips_2010 <- gc_gridcoord(nm_county_fips_2010, "county")
#'
#' year_coord <- generate_date_range(lubridate::ymd("1973-01-01"),
#'                                   lubridate::ymd("1991-01-01"),
#'                                   time_division = "year")
#'
#' glm_func <- function(space_coord, time_coord, data_for_model) {
#'   mod <- glm(count ~ year,
#'              family = poisson(link = "log"),
#'              offset = log(population),
#'              data = data_for_model)
#'   return(list(fit = mod,
#'               data = data_for_model))
#' }
#'
#' fits_and_data <- loop_model(nm_county_fips_2010, year_coord, NM_popcas,
#'                             outcome_col = "count",
#'                             path_to_model = glm_func)
#' all_fits <- fits_and_data[[1]]
#' all_data <- fits_and_data[[2]]
#'
#' all_yhats <- loop_extract_yhat(nm_county_fips_2010, year_coord, all_fits, all_data,
#'                                yhat_extractor_name = "extract",
#'                                use_surveillance_residuals = FALSE)
#'
#'
#' # Finally, crate alarm statistics
#' # A scan-type alarm:
#' all_alarms <- loop_alarm_function(nm_county_fips_2010, year_coord, all_yhats, all_data,
#'                                   outcome_col = "count",
#'                                   alarm_function_name = "scan_eb_poisson",
#'                                   max_k = 3,
#'                                   n_mcsim = 10)
#'
#' all_alarms <- loop_alarm_function(nm_county_fips_2010, year_coord, all_yhats, all_data,
#'                                   outcome_col = "count",
#'                                   alarm_function_name = "scan_bayes_negbin",
#'                                   max_k = 3)
#'
#'
#' # Or a parallel-type alarm:
#' all_alarms <- loop_alarm_function(nm_county_fips_2010, year_coord, all_yhats, all_data,
#'                                   outcome_col = "count",
#'                                   alarm_function_name = "parallel_cusum_poisson",
#'                                   extra_alarm_args = list(scaling = 1.25))
loop_alarm_function <- function(fits_and_data,
                                outcome_col,
                                alarm_function_name,
                                run_on_surveillance = TRUE,
                                grow_surveillance = TRUE,
                                max_k,
                                spatial_lookup = NULL,
                                n_mcsim = 10,
                                ...) {

  ### Combine the data spatially, if split ----
  fits_and_data <- collapse_if_exploded(fits_and_data)


  ### Argument checks ----
  check_scalar_type(outcome_col, "character")
  check_scalar_type(alarm_function_name, "character")


  ### Prep steps for scan-type alarms functions ----
  zones <- NULL
  key_matrix <- NULL
  alarm_type <- calculate_alarm_type(alarm_function_name)
  if (alarm_type == "scan") {
    check_scalar_type(max_k, "integer")
    check_type(spatial_lookup, "sf")
    if (max_k < 0) {
      stop("max_k must be greater than 0")
    } else if (max_k > nrow(spatial_lookup)) {
      stop("max_k must be less than the number of spatial areas")
    }

    zones <- space_coord_to_zones(spatial_lookup, max_k = max_k)
    key_matrix <- zones_to_key_matrix(zones)
  }


  ### ~~~3. Loop through all the model fits ----
  # What do we calculate the scan statistics on? Regular or surveillance data?
  # And do we grow it or not?


  if (run_on_surveillance && !("surveillance_data" %in% colnames(fits_and_data))) {
    # Currently this exists in both loop_extract_yhat and loop_alarm_function
    # I'm not quite sure where it belongs.
    fits_and_data <- calculate_surveillance_residuals(fits_and_data, grow_surveillance)
  }


  if (run_on_surveillance) {
    wanted_row_ids <- find_wanted_rows(fits_and_data, surveillance_data)
  } else {
    wanted_row_ids <- find_wanted_rows(fits_and_data, augmented_data)
  }

  p <- progressr::progressor(length(wanted_row_ids))

  all_scan_res <- rep(list(NULL), nrow(fits_and_data))
  for (i in wanted_row_ids) {
    curr_row <- fits_and_data[i, ]
    if (run_on_surveillance) {
      curr_data <- fits_and_data$surveillance_data[[i]]
    } else {
      curr_data <- fits_and_data$augmented_data[[i]]
    }

    all_scan_res[[i]] <- call_alarm_function(alarm_function_name,
                                             curr_data,
                                             outcome_col,
                                             zone_info = zones,
                                             n_mcsim,
                                             ...)
    p()
  }
  fits_and_data$scan_results <- all_scan_res
  return(fits_and_data)

}

