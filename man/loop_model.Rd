% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/loop_model.R
\name{loop_model}
\alias{loop_model}
\title{Fit a model over multiple time windows}
\usage{
loop_model(
  spacetime_data,
  outcome_col,
  model_function,
  data_prep_function = NULL,
  min_train = 7,
  max_train = Inf,
  n_predict = 1,
  step = 1,
  model_arity = c("multi", "uni"),
  prediction_strategy = c("NA", "truncate"),
  ...
)
}
\arguments{
\item{outcome_col}{The name of the column in \code{data_for_model} containing the primary outcome
(e.g., the number of elevated cases).}

\item{min_train}{The minimum number of time points to include in each model fit}

\item{max_train}{The maximum number of time poitns to include in each model fit}

\item{n_predict}{How many time points should be predicted each time the model is fit}

\item{model_arity}{Can the model handle multiple spatial regions as once (\code{"multi"}) or only
one (\code{ "uni"})}

\item{space_coord}{A gridcoord object
(\code{\link[gridcoord]{gc_gridcoord}}) describing the spatial area that is
covered by \code{data_for_model}.}

\item{time_coord}{A gridcoord object (\code{\link[gridcoord]{gc_gridcoord}})
describing the temporal area that is to be covered by the model. This coordinate must be
ordered, with the first entries in the dataframe corresponding to the earliest time periods and
the last entries corresponding to the most recent.}

\item{data_for_model}{A data frame containing all of the covariate information required by the
model. In addition, \code{data_for_model} must have two columns with the same column name and
entries as the left-most columns in \code{space_coord} and \code{time_coord} columns.}

\item{path_to_model}{The path to the model function, or the function itself. If a path to the
model function, it must point to a .R file containing a single function. See the Details
section or \code{vignette("model-functions")} for a more in-depth explanation.}

\item{use_cache}{Should the results from this function be saved (cached), so that the results can
be quickly loaded without having to fit a (possibly very complicated) model.}

\item{force}{If previous results have been cached, should the function be forced to redo the
calculations? \code{force} can be a single logical value or a vector indicating specific time
points to be re-calculated.}

\item{save_environments}{Should any environments captured by formulas or model fits be included
in the saved results? See the \code{Caching} section for details.}

\item{verbose}{Should updates be printed to the console?}

\item{extra_model_args}{A named list containing additional parameters to supply to the model
function. See \code{vignette("model-functions")} for an oveview of how this works.}
}
\value{
A hierarchically organized list. At the top level, the returned list will contain the
components "fit", "data", and any additional values returned by the model function. If
\code{model_arity = "multi"} or there was only one spatial region, then each component will be
a list organized by time. If \code{model_arity = "uni"}, then each component will be a
\link[gridcoord]{gridlist}, organized first by spatial region and then by time.
}
\description{
\code{loop_model} fits a model to multiple sequential time points, optionally also
over multiple spatial regions
}
\section{Model fit functions}{

\code{loop_model} repeatedly fits a model function to data, but supplying the model function is up to
the user. The model must be supplied in the form of a function whose first three arguments are
\code{space_coord}, \code{time_coord}, and \code{data_for_model}. The function must return a list,  where the
first element is the model fit object and is named "fit", and the second element is the
data.frame used by the fitting function and is named "data". The function can take any number of
additional arguments, which can be passed to the model function by including them as entries in
the \code{extra_model_args} parameter, and it can return any number of additional values by including
them as extra entries in the returned list.
}

\section{Caching overview}{

Caching in the \code{statsurv} is done using the \code{\link[simplecache:cache_wrap]{simplecache}}
package. The first time you run this function with \code{use_cache = TRUE}, it will create a
sub-directory based on the value of \code{path_to_model}, where it will save the returned values
from every iteration. The next time you run the function, \code{simplecache} will check if the
function inputs are identical to a previous run. If so, \code{simplecache} will load the model
output from disc instead of re-fitting the model.

Determing when to use the cache is not always straightforward, so it is possible that
\code{simplecache} will make a mistake sometimes and use a cached value when it should not. The
\code{force} argument to allows you to override the default behavior, and force the function to
re-calculate the results from scratch.

Some functions take an additional argument \code{save_environments} that controls how fit objects
and formulas as saved. These objects often capture their entire environment when they are
created, which can cause the saved objects to be extremely large. Setting
\code{save_environments = FALSE} removes the captured environments from the model fits when
saving them.
}

\examples{
\dontrun{
# Define our coordinates and generate data
space_coord <- data.frame(space_label = c("space1", "space2"),
                          stringsAsFactors = FALSE)
time_coord <- data.frame(time_label = paste0("t", 1:10),
                         time = 1:10,
                         fin_time = 2:11,
                         stringsAsFactors = FALSE)
data_for_model <- expand.grid(space_label = space_coord[[1]],
                              time_label = time_coord[[1]],
                              stringsAsFactors = FALSE)
data_for_model$x <- runif(nrow(data_for_model), max = 15)
data_for_model$y <- data_for_model$x * 1.05 +
                        rnorm(nrow(data_for_model))

# Define our model function
simple_lm_func <- function(space_coord,
                           time_coord,
                           data_for_model) {
  fit <- lm(y ~ x,
            data = data_for_model)
   return(list(fit = fit,
              data = data_for_model))
}

# Run the model as repeated surveillance
loop_model(space_coord, time_coord, data_for_model, "y",
           simple_lm_func,
           min_train = 5,
           use_cache = FALSE)

# Run the same model, but fit it
# seperately to each spatial region
loop_model(space_coord, time_coord, data_for_model, "y",
           simple_lm_func,
           min_train = 5,
           use_cache = FALSE,
           model_arity = "uni")
}
}
\seealso{
Other looping functions: 
\code{\link{loop_alarm_function}()},
\code{\link{loop_extract_yhat}()},
\code{\link{loop_over}()}
}
\concept{looping functions}
