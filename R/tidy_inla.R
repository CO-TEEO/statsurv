#' Report information about the components of an INLA model
#'
#' \code{\link[broom]{tidy}} summarizes information about the components of a model. `tidy_inla`
#' adapts this to INLA models.
#'
#' @param fit The model fit object generated by INLA.
#' @param include_random Boolean. Should information about random effects be included in the
#'   results?
#'
#' @return A data frame containing estimates and standard errors of the coefficients in `fit`, with
#'   one row per coefficient. The result will always contain the results for fixed effects and
#'   hyperparameters. If `include_random = TRUE`, the result will also include all the random
#'   effects, such as the individual effects from an `iid` or `BYM` model. The data frame contains
#'   the columns "term", "estimate", "std.error", "statistic", "p.value", and "type".
#' @export
#' @md
#' @seealso \code{\link[broom]{tidy}} \code{\link{glance_inla}}
#'
#' @examples
#' x <- rnorm(20, mean = 0, sd = 3)
#' y <- 1.3 + 2.5 * x + rnorm(20, sd = 1)
#' df <- data.frame(x = x, y = y)
#'
#' \dontrun{
#' fit_inla <- INLA::inla(y ~ x, data = df)
#' tidy_inla(fit_inla)
#'
#' data(NM_data)
#' fit_inla <- INLA::inla(count ~ population + f(county, model = "iid"),
#'                        data = NM_data)
#' tidy_inla(fit_inla, include_random = TRUE)
#' }
tidy_inla <- function(fit, include_random = FALSE) {
  # We want the columns: term, estimate, std. error, statistic, p.value
  # I'm not sure what most of these are. I guess they're just t-statistics.
  # For p. values, we don't have to assume a normal distribution.
  stopifnot(inherits(fit, "inla"),
            rlang::is_scalar_logical(include_random))

  # For our first approach, we just combine the summary_fixed and summary_hyper
  null_df <- data.frame(mean = c(1), sd = c(1))[c(), ]
  fixed_df <- rbind(null_df, fit$summary.fixed[, c("mean", "sd")])
  hyper_df <- rbind(null_df,
                    fit$summary.hyperpar[, c("mean", "sd")])
  fixed_df$type <- rep("fixed", nrow(fixed_df))
  hyper_df$type <- rep("hyper", nrow(hyper_df))

  fixed_df$term <- rownames(fixed_df)
  hyper_df$term <- rownames(hyper_df)

  summary_df <- rbind(fixed_df, hyper_df)
  all_marginals <- c(fit$marginals.fixed, fit$marginals.hyperpar)

  if (include_random) {
    random_est <- list()
    null_random_df <- data.frame(group = c(1), mean = c(1), sd = c(1))[c(), ]
    for (name in names(fit$summary.random)) {
      q_df <- fit$summary.random[[name]]
      col1 <- names(q_df)[[1]]
      q_df <- q_df[, c(col1, "mean", "sd")]
      q_df$group <- name
      random_est[[name]] <- q_df
    }
    random_df <- do.call(rbind, random_est)
    random_df$term <- random_df[[1]]
    random_df <- rbind(null_random_df, random_df[, -1])
    random_df$type <- rep("random", nrow(random_df))
    random_marginals <- unlist(fit$marginals.random, recursive = FALSE)

    summary_df$group <- NA
    summary_df <- rbind(summary_df, random_df)
    all_marginals <- c(all_marginals, random_marginals)
  }


  summary_df$statistic <- summary_df$mean / summary_df$sd


  pval <- sapply(all_marginals, INLA::inla.pmarginal, q = 0)

  summary_df$p.value <- ifelse(summary_df$mean < 0, 1 - pval, pval)
  summary_df$estimate <- summary_df$mean
  summary_df$std.error <- summary_df$sd

  rownames(summary_df) <- NULL
  wanted_col <- c("term", "estimate", "std.error", "statistic", "p.value", "type")
  if (include_random) {
    wanted_col <- c(wanted_col, "group")
  }
  summary_df <- summary_df[, wanted_col, drop = FALSE] %>%
    tibble::as_tibble()
  return(summary_df)
}



#' Summarize an INLA model
#'
#' \code{\link[broom]{glance}} summarizes a model into a data frame. `glance_inla` adapts this to
#' INLA models.
#'
#' @inheritParams tidy_inla
#'
#' @return A 1-row data frame containing information on goodness of fit, p-values, or model
#'   convergence for the model object. Contains information on DIC, WAIC, the log likelihood and CPO.
#' @export
#' @md
#'
#' @examples
#' x <- rnorm(20, mean = 0, sd = 3)
#' y <- 1.3 + 2.5 * x + rnorm(20, sd = 1)
#' df <- data.frame(x = x, y = y)
#'
#' \dontrun{
#' fit_inla <- INLA::inla(y ~ x, data = df)
#' glance_inla(fit_inla)
#'
#' data(NM_data)
#' fit_inla <- INLA::inla(count ~ population + f(county, model = "iid"),
#'                        data = NM_data,
#'                        control.compute = list(dic = TRUE, cpo = TRUE, waic = TRUE))
#' glance_inla(fit_inla)
#' }
glance_inla <- function(fit) {
  glance_list <- list(cpu.time = fit$cpu.used["Total"],
                      deviance = fit$dic$deviance.mean,
                      logLik = fit$mlik[nrow(fit$mlik), 1],
                      DIC = fit$dic$dic,
                      DIC.sat = fit$dic$dic.sat,
                      WAIC = fit$waic$waic,
                      cpo.failures =  sum(is.na(fit$cpo$failure)) +
                        sum(fit$cpo$failure, na.rm = TRUE),
                      cpo.logsum = sum(log(fit$cpo$cpo), na.rm = TRUE))
  m <- sapply(glance_list, is.null)
  glance_list[m] <- NA

  glance_df <- tibble::as_tibble(glance_list)
  return(glance_df)
}
