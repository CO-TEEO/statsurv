% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/arima_tidy.R
\name{arima_tidy}
\alias{arima_tidy}
\title{Fit ARIMA models via formula}
\usage{
arima_tidy(
  f,
  data,
  order = c(0L, 0L, 0L),
  seasonal = list(order = c(0L, 0L, 0L), period = NA),
  include.mean = TRUE,
  transform.pars = TRUE,
  fixed = NULL,
  init = NULL,
  method = c("CSS-ML", "ML", "CSS"),
  n.cond,
  SSint = c("Gardner1980", "Rossignol2011"),
  optim.method = "BFGS",
  optim.control = list(),
  kappa = 1e+06
)
}
\arguments{
\item{f}{A \code{\link{stats::formula}} describing the response variable and any external
regressors to be used in the arima model. All variables included in \code{f} must be contained in
\code{data}. The response variable is passed to \code{\link[arima]{stats}} as \code{x} and all external
regressors are passed as \code{xreg}.}

\item{data}{A data frame or data frame extension (e.g., a tibble) containing all of the variables
in the model}

\item{order}{A specification of the non-seasonal part of the ARIMA
    model: the three integer components \eqn{(p, d, q)} are the AR order, the
    degree of differencing, and the MA order.}

\item{seasonal}{A specification of the seasonal part of the ARIMA model, plus the period. This
must be specified by a list with components order and period.}

\item{include.mean}{Should the ARMA model include a mean/intercept term?  The
    default is \code{TRUE} for undifferenced series, and it is ignored
    for ARIMA models with differencing.}

\item{transform.pars}{logical; if true, the AR parameters are
    transformed to ensure that they remain in the region of
    stationarity.  Not used for \code{method = "CSS"}.  For
    \code{method = "ML"}, it has been advantageous to set
    \code{transform.pars = FALSE} in some cases, see also \code{fixed}.}

\item{fixed}{optional numeric vector of the same length as the total
    number of coefficients to be estimated.  It should be of the form
    \deqn{(\phi_1, \ldots, \phi_p, \theta_1, \ldots, \theta_q,
      \Phi_1, \ldots, \Phi_P, \Theta_1, \ldots, \Theta_Q, \mu),
    }{(phi_1, ..., phi_p, theta_1, ..., theta_p,Phi_1,..., Phi_P, Theta_1,...,Theta_Q, mu),}
    where \eqn{\phi_i}{phi_i} are the AR coefficients,
    \eqn{\theta_i}{theta_i} are the MA coefficients,
    \eqn{\Phi_i}{Phi_i} are the seasonal AR coefficients,
    \eqn{\Theta_i}{Theta_i} are the seasonal MA coefficients and
    \eqn{\mu}{mu} is the intercept term.  Note that the \eqn{\mu}{mu}
    entry is required if and only if \code{include.mean} is \code{TRUE}.
    In particular it should not be present if the model is an ARIMA
    model with differencing.

    The entries of the \code{fixed} vector should consist of the
    values at which the user wishes to \dQuote{fix} the corresponding
    coefficient, or \code{NA} if that coefficient should \emph{not} be
    fixed, but estimated.

    The argument \code{transform.pars} will be set to \code{FALSE} if any
    AR parameters are fixed.  A warning will be given if \code{transform.pars}
    is set to (or left at its default) \code{TRUE}.  It may be wise to set
    \code{transform.pars = FALSE} even when fixing MA parameters,
    especially at values that cause the model to be nearly non-invertible.
  }

\item{init}{optional numeric vector of initial parameter
    values.  Missing values will be filled in, by zeroes except for
    regression coefficients.  Values already specified in \code{fixed}
    will be ignored.}

\item{method}{fitting method: maximum likelihood or minimize
    conditional sum-of-squares.  The default (unless there are missing
    values) is to use conditional-sum-of-squares to find starting
    values, then maximum likelihood.  Can be abbreviated.}

\item{n.cond}{only used if fitting by conditional-sum-of-squares: the
    number of initial observations to ignore.  It will be ignored if
    less than the maximum lag of an AR term.}

\item{optim.method}{The value passed as the \code{method} argument to
    \code{\link[stats]{optim}}.}

\item{optim.control}{List of control parameters for \code{\link[stats]{optim}}.}

\item{kappa}{the prior variance (as a multiple of the innovations
    variance) for the past observations in a differenced model.  Do not
    reduce this.}
}
\value{
A model fit object of class "arima_tidy". This is an extension of the Arima model fit
produced by \code{\link[stats]{arima}}, so functions such as \code{\link[stats]{predict}} will
work identically. The output of \code{arima_tidy} contains some additional components that make
working with them easier:
\describe{
\item{formula}{The formula used to fit the model}
\item{data}{The data used to fit the model}
\item{xreg}{The generated values of \code{xreg} used as external regressors}
\item{fitted}{The fitted values produced by the model. The output of \code{\link[stats]{arima}}
contains the residuals, but not the fitted values.}
}
}
\description{
\code{arima_tidy} is a wrapper around \code{\link[arima]{stats}} that allows you to specify the
response variable and any external regressors for an ARIMA model using a data.frame and formula,
instead of having to manually generate \code{xreg}. This makes the workflow for fitting ARIMA models
much closer to the workflow for fitting \code{lm} or \code{glm} models.
}
\examples{
data("LakeHuron")
LakeHuron_df <- data.frame(lake_level = as.numeric(LakeHuron),
                           date = seq(start(LakeHuron)[[1]],
                                      end(LakeHuron)[[1]],
                                      by = 1))
LakeHuron_df$election_year = LakeHuron_df$date \%\% 4 == 0

# Basically anything that works in a formula can be used in arima_tidy
arima_tidy(lake_level ~ I(date - 1920), data = LakeHuron_df, order = c(2, 0, 0))

arima_tidy(sqrt(y) ~ date + is_election_year, data = LakeHuron_df, order = c(2, 0, 0))

# We can reference variables outside of the `data` argument

shift <- 2000
arima_tidy(sqrt(y) ~ log(date + shift),  data = LakeHuron_df, order = c(2, 0, 0))

# We can handle data with NA's and seasonal data:
data("presidents_df")

arima_tidy(y ~ 1, data = presidents_df, order = c(1, 0, 0))

# We lose the frequency information when the data is
# stored in a data.frame, so we have to specify
# the period manually for seasonal approaches:
arima_tidy(y ~ 1, data = presidents_df, order=c(2,0,1),
           seasonal= list(order = c(1,0,0), period = 4),
           fixed=c(NA, NA, 0.5, -0.1, 50), transform.pars=FALSE)
}
\seealso{
\code{\link[stats]{arima}}, \code{\link{predict.arima_tidy}}, \code{\link{augment.arima_tidy}}
}
