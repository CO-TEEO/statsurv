#' @title Summarize information from multiple alarm functions
#'
#' @description `extract_alarm_statistic` combines information from a list of alarm statistics
#'   calculated at different times to provide an overview about the alarm statistic in a particular
#'   zone over time or the maximum value of the alarm statistic over time.
#'
#' @param space_coord A gridcoord object
#'   (\code{\link[gridcoord]{gc_gridcoord}}) describing the spatial area that is
#'   covered by `list_of_alarms`
#' @param time_coord A gridcoord object (\code{\link[gridcoord]{gc_gridcoord}})
#'   describing the time points that are covered by `list_of_alarms`. This coordinate must be
#'   an ordered dataframe, with the first entries corresponding to the earliest time periods and
#'   the last entries corresponding to the most recent.
#' @param list_of_alarms A list of scan-type alarm function results, as generated by
#'   \code{\link{loop_alarm_function}}. Each alarm function result must contain the components
#'   `observe` and `replicates`, and both of these components must contain the column
#'   `action_level`. This can be ensured by generating `list_of_alarms` with
#'   \code{\link{loop_alarm_function}} or \code{\link{standardized_alarm_functions}}.
#' @param zone The index of the zone to report the alarm statistic for. If NULL (default), reports
#'   the zone with the highest value of the alarm statistic at each time point.
#'
#' @return A data.frame containing one row per time point. In addition to the columns contained in
#'   the alarm function results and a column corresponding to the time coordinate, the data.frame
#'   will contains the following columns:
#'   \describe{
#'   \item{upper_control_limit}{The 97.5 percentile of the scan statistic calcluated by Monte Carlo
#'   simulation. An `action_level` above this value is evidence that the observed behavior does not
#'   match what would be expected based on the model. If the scan statistic was calculated with the
#'   parameter `n_mcsim = 0`, then this column with be `NA`.}
#'   \item{alert_start_label}{The label of the time coordinate when the potential outbreak began.}
#'   }
#'   If `time_coord` is a span-type gridcoord, then data.frame will contain two additional columns:
#'   \describe{
#'   \item{surveillance_date}{The start date of the span when the surveillance was performed.}
#'   \item{alert_start_date}{The start date of the time span when the potential outbreak began.}
#'   }
#'
#' @export
#' @md
#' @examples
#' # Using pre-computer alarm statistics for New Mexico
#' nm_county_fips_2010 <- statsurv::nm_county_coord
#' nm_scan_alarms <- statsurv::nm_scan_alarms
#'
#' year_coord <- generate_date_range(lubridate::ymd("1973-01-01"),
#'                                   lubridate::ymd("1991-01-01"),
#'                                   time_division = "year")
#' extract_alarm_statistic(nm_county_fips_2010, year_coord, nm_scan_alarms)
#' extract_alarm_statistic(nm_county_fips_2010, year_coord, nm_scan_alarms, zone = 4)
extract_alarm_statistic <- function(space_coord, time_coord, list_of_alarms, zone = NULL) {

  filter_f <- function(x) {
    x <- standardize_alarm(x, "scan")
    df <- x$observed
    if (!is.null(zone)) {
      df <- df %>%
        dplyr::filter(.data$zone == .env$zone)
    }
    df <- df %>%
      dplyr::filter(.data$action_level == max(.data$action_level)) %>%
      dplyr::filter(dplyr::row_number() == 1)

    if (nrow(df) == 0) {
      # Hack to deal with 0-row df's
      df <- x$observed %>%
        dplyr::filter(dplyr::row_number() == 1) %>%
        dplyr::mutate_all(function(x) NA)
    }
    return(df)

  }

  ### Argument checks ----
  space_coord <- gridcoord::gc_gridcoord(space_coord)
  time_coord <- gridcoord::gc_gridcoord(time_coord)
  check_type(list_of_alarms, "list")
  check_type(zone, c("NULL", "character", "numeric"))
  eg_alarm <- list_of_alarms[[length(list_of_alarms)]]
  check_type(eg_alarm, "scanstatistic")


  ### Computation ----
  mlc_zonescores_list <-   loop_over(space_coord, time_coord, list_of_alarms, filter_f,
                                     verbose = FALSE)

  tc_name <- gridcoord::gc_get_name(time_coord)
  mlc_zonescores_df <- do.call(rbind, mlc_zonescores_list)
  mlc_zonescores_df[[tc_name]] <- rownames(mlc_zonescores_df)

  actionthresholds_list <- loop_over(space_coord, time_coord,
                                     list_of_alarms,
                                     function(x) {
                                       stats::quantile(x$replicates$action_level, 0.975)
                                       },
                                     verbose = FALSE)
  actionthresholds_df <- do.call(rbind, actionthresholds_list)
  scanscores_df <- cbind(mlc_zonescores_df, actionthresholds_df) %>%
    dplyr::rename(upper_control_limit = .data$`97.5%`)
  # Then we have to do some annoying matching in order to get both the date of the surveillance and
  # the start date of the alert

  date_index <- gridcoord::gc_get_match(scanscores_df, time_coord)
  scanscores_df$alert_start_label <- time_coord[[tc_name]][date_index - scanscores_df$duration + 1]

  if (is.data.frame(time_coord) && ncol(time_coord) == 3) {
    scanscores_df$surveillance_date <- time_coord[[2]][date_index]
    scanscores_df$alert_start_date <- time_coord[[2]][date_index - scanscores_df$duration + 1]
  }
  scanscores_df <- scanscores_df %>%
    dplyr::select(.env$tc_name, dplyr::everything())
  rownames(scanscores_df) <- NULL
  return(scanscores_df)
}
