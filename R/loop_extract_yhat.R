#' @title Predict Values From a Series of Model Fits
#'
#' @description Given a set of model fits, extract predicted values ('yhat') from the model objects.
#'
#' @param space_coord A gridcoord object
#'   (\code{\link[gridcoord]{gc_gridcoord}}) describing the spatial area that is
#'   covered by `list_of_model_fits` and `list_of_model_data`.
#' @param time_coord A gridcoord object (\code{\link[gridcoord]{gc_gridcoord}}) describing the
#'   temporal area that is covered by `list_of_model_fits` and `list_of_model_data`. This coordinate
#'   must be ordered, with the first row in the data.frame corresponding to the earliest time
#'   period and the last row corresponding to the most recent.
#' @param list_of_model_fits Either a list or a \link[gridcoord]{gridlist}, generated by
#'   \code{\link{loop_model}}. Each entry of `list_of_model_fits` must be a model fit object, such
#'   as that generated by `lm` or `glm`. These entries must either be in a single list organized by
#'   time, or a \link[gridcoord]{gridlist} organized by both space and time.
#' @param list_of_model_data Either a list or a \link[gridcoord]{gridlist}, generated by
#'   \code{\link{loop_model}}. Each entry of `list_of_model_data` must be a data.frame with columns
#'   corresponding to `space_coord`, `time_coord`, and a column containing the primary outcome of
#'   interest. These entries must either be in a single list organized by time, or a
#'   \link[gridcoord]{gridlist} organized by both space and time.
#' @param yhat_extractor_name How should predicted values be extracted from the model fits. Valid
#'   values are "extract" (the default), "sample", or a user-supplied custom function. See section
#'   "Extrator Functions" for more details.
#' @param use_surveillance_residuals Should the function return surveillance predicted values
#'   (`TRUE`) or ordinary predicted values (`FALSE`)
#' @param path_to_model The path to the model function, or the function itself, that was  used to
#'   calculate the model fits in \code{\link{loop_model}}. This parameter is used only to
#'   determine where cached results should be saved, if caching is being used.
#' @param use_cache Should the results from this function be saved (cached), so that the results can
#'   be quickly loaded without having to re-run the calculation? Likely only to save time when
#'   sampling from a complex Monte-Carlo type model.
#' @param force If previous results have been cached, should the function be forced to redo the
#'   calculations? \code{force} can be a single logical value or a vector indicating specific time
#'   points to be re-calculated.
#' @param verbose Should updates be printed to the console?
#' @param n_samples If `yhat_extractor_name = 'sample'`, how many samples should be taken?
#' @param extra_extractor_args A named list containing additional parameters to supply to the
#'   extractor function. See section "Extrator Functions" for more details.
#'
#' @return A hierarchically organized list, where each entry is a data.frame with columns
#'   corresponding to `space_coord`, `time_coord`, and one or more columns of predicted values.
#'   These entries will either be in a single list organized by time, or a a
#'   \link[gridcoord]{gridlist} organized by both space and time,  depending on the format of
#'   `list_of_model_data` and `list_of_model_fits`.
#'
#' @section Surveillance Residuals: In contrast to ordinary residuals, which are reported for all
#'   data points, surveillance residuals are only reported for points that were not used to
#'   calculate the model fit. For a surveillance model run at time *t*, data points *0*-*t-1* are
#'   typically used to fit the model, but predictions are made on data points *0*-*t*. If
#'   `use_surveillance_residuals = FALSE`, then the model fit at time *t* will be used to report all
#'   the predicted values. If `use_surveillance_residuals = TRUE`, then the model fit at time *t*
#'   will used to report only the predicted values at time *t*, the model fit at time *t-1* will be
#'   used to report the predicted values time *t-1*, etc.
#'
#' @section Using `loop_extract_yhat` with \code{\link{loop_model}}:
#'   `loop_extract_yhat` is designed
#'   to used in conjunction with \code{\link{loop_model}}. The coordinate arguments, `space_coord`
#'   and `time_coord` should be identical to those used by \code{\link{loop_model}}.
#'   `list_of_model_fits` and `list_of_model_data` should be the first and second components of the
#'   hierarchical list returned by \code{\link{loop_model}}. `path_to_model` is optional for
#'   `loop_extract_yhat`, but to most clearly organize the cached information, it should match the
#'   value used in \code{\link{loop_model}}.
#'
#' @section Extractor Functions:
#'   There are currently three different ways to predict values from the
#'   model fits using `loop_extract_yhat`, depending on the value of the `yhat_extactor_name`
#'   argument. If `yhat_extractor_name = "extract"`, then a single point estimate of the predicted
#'   values will be returned. Currently allowed fits for this option are \code{\link[stats]{lm}},
#'   \code{\link[stats]{glm}}, \code{\link[INLA]{inla}}, and \code{\link[forecast]{Arima}}.
#'
#'   If `yhat_extractor_name = "sample"`, then a distribution of possible values will be calculated,
#'   using the \code{\link[arm]{sim}} method from the `arm` package. The number of samples is
#'   controlled by the `n_samples` parameter. Currently allowed fits for this options are
#'   \code{\link[stats]{lm}}, \code{\link[stats]{glm}} and \code{\link[INLA]{inla}}.
#'
#'   If neither of the two built in options are sufficient, a custom function can be passed as the
#'   argument to `yhat_extractor_name`. This function must take as its first four arguments
#'   `space_coord`, `time_coord`, `fit`, and `data`, and it must return a data.frame with columns
#'   corresponding to `space_coord`, `time_coord`, and one or more columns of predicted values.
#'   Unlike the custom functions in \code{\link{loop_model}}, these function *cannot* return any
#'   additional information. Use the \code{\link{loop_over}} function if you need to compute
#'   additional values for each model fit.
#'
#'   ## Additional arguments:
#'   The \code{\link[forecast]{Arima}} "extract" method and many custom extraction functions require
#'   additional arguments. These can be passed from `loop_extract_yhat` to the extractor function by
#'   including them as entries in the `extra_model_args` parameter. All the components in
#'   `extra_model_args` will be passed through unchanged to the extractor function, **unless** any
#'   of the components are lists or \link[gridcoord:gridlist]{gridlists} with the same names as the
#'   `list_of_model_data` argument. In this case, each time the extrctor function is run,
#'   `loop_extract_yhat` will pass a different element of the component into the extractor function.
#'
#' @inheritSection loop_model Caching overview
#' @examples
#' ## Not run:
#' # Define our coordinates and generate data
#' space_coord <- data.frame(space_label = c("space1", "space2"), stringsAsFactors = FALSE)
#' time_coord <- data.frame(time_label = paste0("t", 1:10),
#'                          time = 1:10,
#'                          fin_time = 2:11,
#'                          stringsAsFactors = FALSE)
#' data_for_model <- expand.grid(space_label = space_coord[[1]],
#'                               time_label = time_coord[[1]],
#'                               stringsAsFactors = FALSE)
#' data_for_model$x <- runif(nrow(data_for_model), max = 15)
#' data_for_model$y <- data_for_model$x * 1.05 + rnorm(nrow(data_for_model))
#'
#' # Define our model function
#' simple_lm_func <- function(space_coord, time_coord, data_for_model) {
#'   fit <- lm(y ~ x,
#'             data = data_for_model)
#' return(list(fit = fit,
#'               data = data_for_model))
#' }
#'
#' # Loop the model
#' all_fits_and_data <- loop_model(space_coord, time_coord, data_for_model, "y",
#'                                 simple_lm_func, min_train = 5, use_cache = FALSE)
#' all_fits <- all_fits_and_data[[1]]
#' all_data <- all_fits_and_data[[2]]
#'
#' # Calculate predicted values for each model fit
#' loop_extract_yhat(space_coord, time_coord, all_fits, all_data,
#'                   yhat_extractor_name = "extract", use_cache = FALSE)
#'
#' ## End (Not run)
#' @family looping functions
#' @seealso \code{\link{extract_yhat}} and \code{\link{sample_yhat}} for details on how the
#'   extractor functions work.
#' @export
#' @md
loop_extract_yhat <- function(fits_and_data,
                              yhat_extractor_name = "extract",
                              data_prep_function = NULL,
                              include_surveillance = TRUE,
                              grow_surveillance_length = TRUE,
                              n_samples = NULL,
                              ...) {

  extra_args <- list(...)


  ### Helper Functions ----


  ### Argument checks ----
  check_type(fits_and_data, "data.frame")
  if (!"id_space" %in% colnames(fits_and_data) || !"id_time" %in% colnames(fits_and_data)) {
    stop_subclass("spacetime_data must have numeric columns 'id_space' and 'id_time' identifying the space and time coordinates")
  }
  check_type(fits_and_data$id_space, "integer")
  check_type(fits_and_data$id_time, "integer")
  if (!"model_fit" %in% colnames(fits_and_data) || !"curr_data" %in% colnames(fits_and_data)) {
    stop_subclass("spacetime_data must have columns 'curr_data' and 'model_fit'",
                  " containing the data used in each fit and the model fit object")
  }

  check_scalar_type(yhat_extractor_name, c("character", "function"))
  check_scalar_type(include_surveillance, "logical")
  check_scalar_type(grow_surveillance_length, "logical")
  check_type(n_samples, c("NULL", "integer"))


  ### Load the extractor function ----
  yhat_extractor_func <- parse_yhat_extractor(yhat_extractor_name)



  # Run through the data_prep_function:
  if (!is.null(data_prep_function)) {
    data_prep_function2 <- skipping_nulls(data_prep_function)
    fits_and_data <- fits_and_data %>%
      dplyr::rowwise() %>%
      dplyr::mutate(args_for_extractor = list(ensure_list(data_prep_function2(curr_data))))
  } else {
    fits_and_data <- fits_and_data %>%
      dplyr::rowwise() %>%
      dplyr::mutate(args_for_extractor = list(list(curr_data)))
  }


  if (identical(yhat_extractor_name, "sample")) {
    if (is.null(n_samples)) {
      n_samples <- 10
    }
    extra_args <- c(extra_args, n_samples)
  }

  wanted_row_ids <- fits_and_data %>%
    dplyr::ungroup() %>%
    dplyr::mutate(.row_id = dplyr::row_number()) %>%
    dplyr::rowwise() %>%
    dplyr::filter(!is.null(model_fit)) %>%
    dplyr::pull(.row_id)

  p <- progressr::progressor(length(wanted_row_ids))

  augmented_data <- fits_and_data$curr_data
  for (i in wanted_row_ids) {
    curr_row <- fits_and_data[i, ]
    augmented_data[[i]] <- rlang::exec(yhat_extractor_func,
                                       fits_and_data$model_fit[[i]],
                                       !!!fits_and_data$args_for_extractor[[i]],
                                       !!!extra_args)
    p()
  }

  fits_and_data$augmented_data <- augmented_data

  if (include_surveillance) {
    fits_and_data <- calculate_surveillance_residuals(fits_and_data, grow_surveillance_length)
  }

  fits_and_data <- fits_and_data %>%
    dplyr::select(-args_for_extractor) %>%
    dplyr::ungroup()
  return(fits_and_data)
}
