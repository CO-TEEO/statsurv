unnest(scanres)
source('~/r-analysis/statsurv/R/rowmute.R')
source('~/r-analysis/statsurv/R/rowmute.R')
usethis::use_test()
source('~/r-analysis/statsurv/R/rowmute.R')
usethis::use_package("rlang")
?mutate
usethis::use_package("progressr")
?`progressr-package`
source('~/r-analysis/statsurv/R/rowmute.R')
devtools::document()
devtools::document()
?rowmute
library(dplyr)
?mutate.data.frame
source('~/r-analysis/statsurv/R/rowmute.R')
devtools::document()
?rowmute
curr_options <- options(statsurv.progress = FALSE)
curr_options
nested_df <- starting_df %>%
tidyr::nest(group)
starting_df <- data.frame(group = rep(1:10, each = 10),
x = rnorm(100))
starting_df$y <- starting_df$x * 2.04 + 1.23
nested_df <- starting_df %>%
tidyr::nest(group)
?tidyr::nest
nested_df <- starting_df %>%
dplyr::group_by(group) %>%
tidyr::nest()
nested_df
nested_df <- starting_df %>%
dplyr::group_by(group) %>%
tidyr::nest() %>%
ungroup()
nested_df <- starting_df %>%
dplyr::group_by(group) %>%
tidyr::nest() %>%
dplyr::ungroup()
nested_df <- starting_df %>%
dplyr::group_by(group) %>%
tidyr::nest(curr_data = dplyr::everything()) %>%
dplyr::ungroup()
nested_df
nested_df <- starting_df %>%
# dplyr::group_by(group) %>%
tidyr::nest(curr_data = -group) %>%
dplyr::ungroup()
nested_df
v1 <- nested_df %>%
dplyr::rowwise() %>%
dplyr::mutate(fit = lm(y ~ x, data = data)) %>%
dplyr::ungroup()
v1 <- nested_df %>%
dplyr::rowwise() %>%
dplyr::mutate(fit = list(lm(y ~ x, data = data))) %>%
dplyr::ungroup()
v1 <- nested_df %>%
dplyr::rowwise() %>%
dplyr::mutate(fit = lm(y ~ x, data = curr_data)) %>%
dplyr::ungroup()
v1 <- nested_df %>%
dplyr::rowwise() %>%
dplyr::mutate(fit = list(lm(y ~ x, data = curr_data))) %>%
dplyr::ungroup()
v1
v2 <- nested_df %>%
rowmute(fit = ym(y ~ x, data = curr_data))
?bind_rows
devtools::load_all(".")
v2 <- nested_df %>%
rowmute(fit = ym(y ~ x, data = curr_data))
devtools::load_all(".")
v2 <- nested_df %>%
rowmute(fit = ym(y ~ x, data = curr_data))
?is_scalar_atomic
devtools::load_all(".")
v2 <- nested_df %>%
rowmute(fit = ym(y ~ x, data = curr_data))
?eval
devtools::load_all(".")
v2 <- nested_df %>%
rowmute(fit = ym(y ~ x, data = curr_data))
devtools::load_all(".")
devtools::load_all(".")
v2 <- nested_df %>%
rowmute(fit = ym(y ~ x, data = curr_data))
devtools::load_all(".")
v2 <- nested_df %>%
rowmute(fit = ym(y ~ x, data = curr_data))
v2 <- nested_df %>%
rowmute(fit = lm(y ~ x, data = curr_data))
devtools::load_all(".")
v2 <- nested_df %>%
rowmute(fit = lm(y ~ x, data = curr_data))
test_that("rowmute matches dplyr", {
v1 <- nested_df %>%
dplyr::rowwise() %>%
dplyr::mutate(fit = list(lm(y ~ x, data = curr_data))) %>%
dplyr::ungroup()
v2 <- nested_df %>%
rowmute(fit = lm(y ~ x, data = curr_data))
expect_equal(v1, v2)
})
nested_df
nested_df <- starting_df %>%
tidyr::nest(curr_data = -group) %>%
dplyr::mutate(even = group %% 2) %>%
dplyr::ungroup()
nested_df
test_that("auto-unlisting works on scalars", {
v1 <- nested_df %>%
dplyr::mutate(q = group + 15)
v2 <- nested_df %>%
rowmute(q = group + 15)
expect_equal(v1, v2)
})
v1 <- nested_df %>%
dplyr::rowwise() %>%
dplyr::mutate(q = list(c(group + 15, group - 1))) %>%
dplyr::ungroup()
?is_atomic
?is.atomic
test_that("auto-unlisting works on scalars", {
v1 <- nested_df %>%
dplyr::mutate(q = group + 15)
v2 <- nested_df %>%
rowmute(q = group + 15)
expect_equal(v1, v2)
expect_true(rlang::is_atomic(v2$q))
})
length(fit)
v2 <- nested_df %>%
rowmute(fit = lm(y ~ x, data = curr_data))
length(v2$fit[[2]])
v1 <- nested_df %>%
dplyr::rowwise() %>%
dplyr::mutate(q = list(c(group + 15, group - 1))) %>%
dplyr::ungroup()
v1
v2 <- nested_df %>%
rowmute(q = list(c(group + 15, group - 1)))
expect_equal(v1, v2)
test_that("auto-unlisting doesn't work on non-scalar atomics", {
v1 <- nested_df %>%
dplyr::rowwise() %>%
dplyr::mutate(q = list(c(group + 15, group - 1))) %>%
dplyr::ungroup()
v2 <- nested_df %>%
rowmute(q = list(c(group + 15, group - 1)))
expect_equal(v1, v2)
expect_true(rlang::is_list(v2$q))
})
v1 <- nested_df %>%
dplyr::mutate(date_date = lubridate::ymd(date_chr))
nested_df$date_chr = "2022-01-22"
v1 <- nested_df %>%
dplyr::mutate(date_date = lubridate::ymd(date_chr))
v1
v1$date_date
attributes(v1$date_date)
v2 <- nested_df %>%
rowmute(date_date = lubridate::ymd(date_chr))
v2
expect_equal(v1, v2)
devtools::load_all(".")
v2 <- nested_df %>%
rowmute(date_date = lubridate::ymd(date_chr))
col
col
col
col
class(col)
col
class(col)
(all(purrr::map_lgl(col, rlang::is_scalar_atomic)))
?unlist
purrr::flatten(col)
?purrr::flatten
vctrs::vec_c(!!!col)
vctrs::vec_c(!!!col) %>% class()
usethis::use_package("vctrs")
devtools::load_all(".")
test_that("auto-unlisting behaves correctly for dates", {
nested_df$date_chr = "2022-01-22"
v1 <- nested_df %>%
dplyr::mutate(date_date = lubridate::ymd(date_chr))
v2 <- nested_df %>%
rowmute(date_date = lubridate::ymd(date_chr))
expect_equal(v1, v2)
})
devtools::load_all(".")
test_that("auto-unlisting behaves correctly for dates", {
nested_df$date_chr = "2022-01-22"
v1 <- nested_df %>%
dplyr::mutate(date_date = lubridate::ymd(date_chr))
v2 <- nested_df %>%
rowmute(date_date = lubridate::ymd(date_chr))
expect_equal(v1, v2)
})
v1 <- nested_df %>%
dplyr::mutate(group_f = factor(group))
v1
v2 <- nested_df %>%
rowmute(group_f = factor(group))
v2
expect_equal(v1, v2)
test_that("rowmute works on factors", {
v1 <- nested_df %>%
dplyr::mutate(group_f = factor(group))
v2 <- nested_df %>%
rowmute(group_f = factor(group))
expect_equal(v1, v2)
})
test_that("rowmute works on factors", {
v1 <- nested_df %>%
dplyr::mutate(group_f = factor(group))
v2 <- nested_df %>%
rowmute(group_f = factor(group))
expect_equal(v1, v2)
expect_true(is.factor(v2$group_f))
})
source('~/.active-rstudio-document')
df %>% dplyr::mutate(frac = new_rational(n, d))
df %>% dplyr::mutate(frac = new_rational(n, d)) %>%
tibble::as_tibble()
new_rational <- function(n = integer(), d = integer()) {
vctrs::vec_assert(n, ptype = integer())
vctrs::vec_assert(d, ptype = integer())
vctrs::new_rcrd(list(n = n, d = d), class = "vctrs_rational")
}
format.vctrs_rational <- function(x, ...) {
n <- field(x, "n")
d <- field(x, "d")
out <- paste0(n, "/", d)
out[is.na(n) | is.na(d)] <- NA
out
}
df <- data.frame(n = c(1L, 2L, 3L), d = 2L)
df %>% dplyr::mutate(frac = new_rational(n, d)) %>%
tibble::as_tibble()
v1 <- df %>% dplyr::mutate(frac = new_rational(n, d)) %>%
tibble::as_tibble()
v2 <- df %>%
rowmute(frac = new_rational(n, d)) %>%
tibble::as_tibble()
v2
test_that("rowmute works on record-style objects", {
library("vctrs")
library("dplyr")
new_rational <- function(n = integer(), d = integer()) {
vctrs::vec_assert(n, ptype = integer())
vctrs::vec_assert(d, ptype = integer())
vctrs::new_rcrd(list(n = n, d = d), class = "vctrs_rational")
}
format.vctrs_rational <- function(x, ...) {
n <- field(x, "n")
d <- field(x, "d")
out <- paste0(n, "/", d)
out[is.na(n) | is.na(d)] <- NA
out
}
df <- data.frame(n = c(1L, 2L, 3L), d = 2L)
v1 <- df %>% dplyr::mutate(frac = new_rational(n, d)) %>%
tibble::as_tibble()
v2 <- df %>%
rowmute(frac = new_rational(n, d)) %>%
tibble::as_tibble()
expect_equal(v1, v2)
})
v1 <- df %>%
dplyr::mutate(frac = new_rational(n, d)) %>%
rowwise() %>%
dplyr::mutate(frac_l = list(new_rational(n, d), new_rational(n, 3))) %>%
ungroup()
v1 <- df %>%
dplyr::mutate(frac = new_rational(n, d)) %>%
rowwise() %>%
dplyr::mutate(frac_l = list(new_rational(n, d), new_rational(n, 3L))) %>%
ungroup()
v1 <- df %>%
dplyr::mutate(frac = new_rational(n, d)) %>%
rowwise() %>%
dplyr::mutate(frac_l = list(c(new_rational(n, d), new_rational(n, 3L)))) %>%
ungroup()
v1
v2 <- df %>%
rowmute(frac = new_rational(n, d),
frac_l = list(c(new_rational(n, d), new_rational(n, 3L)))) %>%
tibble::as_tibble()
expect_equal(v1, v2)
test_that("rowmute works on record-style objects", {
library("vctrs")
library("dplyr")
new_rational <- function(n = integer(), d = integer()) {
vctrs::vec_assert(n, ptype = integer())
vctrs::vec_assert(d, ptype = integer())
vctrs::new_rcrd(list(n = n, d = d), class = "vctrs_rational")
}
format.vctrs_rational <- function(x, ...) {
n <- field(x, "n")
d <- field(x, "d")
out <- paste0(n, "/", d)
out[is.na(n) | is.na(d)] <- NA
out
}
df <- tibble::tibble(n = c(1L, 2L, 3L), d = 2L)
v1 <- df %>%
dplyr::mutate(frac = new_rational(n, d)) %>%
rowwise() %>%
dplyr::mutate(frac_l = list(c(new_rational(n, d), new_rational(n, 3L)))) %>%
ungroup()
v2 <- df %>%
rowmute(frac = new_rational(n, d),
frac_l = list(c(new_rational(n, d), new_rational(n, 3L)))) %>%
tibble::as_tibble()
expect_equal(v1, v2)
})
class(v1$frac)
class(v1$frac_l)
test_that("rowmute works on record-style objects", {
library("vctrs")
library("dplyr")
new_rational <- function(n = integer(), d = integer()) {
vctrs::vec_assert(n, ptype = integer())
vctrs::vec_assert(d, ptype = integer())
vctrs::new_rcrd(list(n = n, d = d), class = "vctrs_rational")
}
format.vctrs_rational <- function(x, ...) {
n <- field(x, "n")
d <- field(x, "d")
out <- paste0(n, "/", d)
out[is.na(n) | is.na(d)] <- NA
out
}
df <- tibble::tibble(n = c(1L, 2L, 3L), d = 2L)
v1 <- df %>%
dplyr::mutate(frac = new_rational(n, d)) %>%
rowwise() %>%
dplyr::mutate(frac_l = list(c(new_rational(n, d), new_rational(n, 3L)))) %>%
ungroup()
v2 <- df %>%
rowmute(frac = new_rational(n, d),
frac_l = list(c(new_rational(n, d), new_rational(n, 3L)))) %>%
tibble::as_tibble()
expect_equal(v1, v2)
expect_true("vctrs_rational" %in% class(v2$frac) )
expect_true(class(v2$frac_l) == "list")
})
v1 <- nested_df %>%
dplyr::mutate(func = mean)
v1
v1 <- nested_df %>%
dplyr::mutate(func = list(mean))
v1
test_that("rowmute works on functions", {
v1 <- nested_df %>%
dplyr::mutate(func = list(mean))
v2 <- nested_df %>%
rowmute(func = mean)
expect_equal(v1, v2)
})
?testthat::test_file()
testthat::test_file("tests/testthat/test-rowmute.R")
v2 <- nested_df %>%
rowmute(z = f(group, even))
f <- function(x, y) {
x + 2*y
}
v2 <- nested_df %>%
rowmute(z = f(group, even))
v2
usethis::use_test()
runif(1, max = 1e8)
spacetime_data <- data.frame(id_space = rep(1:10, each = 10),
id_time = rep(1:10, 10),
x = rnorm(100))
spacetime_data
x = rnorm(100)
spacetime_data <- data.frame(id_space = rep(1:10, each = 10),
id_time = rep(1:10, 10),
x = x,
y = 2.04 * x + 1.23)
?rlang::is_integerish
is_integerish(10.000001)
rlang::is_integerish(10.000001)
rlang::is_integerish(1:4)
validate_spacetime_data <- function(df) {
# This is basically the definition of the spacetime dataframe.
# Requirements:
# Has the columns id_time and id_space
# Each is integers or equivalent
# Each has the values seq(min, max, by = 1)
if (!"id_time" %in% colnames(df) || !"id_space" %in% colnames(df)) {
stop_subclass("dataframes used in statsurv must include the columns 'id_time' and 'id_space'",
.subclass = "error_bad_spacetimedata")
}
if (!rlang::is_integerish(df$id_time, finite = TRUE)) {
stop_subclass("The column 'id_time' must be made of whole numbers with no gaps or skips",
.subclass = "error_bad_spacetimedata")
}
if (!rlang::is_integerish(df$id_space, finite = TRUE)) {
stop_subclass("The column 'id_space' must be made of whole numbers with no gaps or skips",
.subclass = "error_bad_spacetimedata")
}
time_uniq_val <- sort(unique(df$id_time))
if (!identical(time_uniq_val, seq(min(df$id_time), max(df$id_time), by = 1))) {
stop_subclass("The column 'id_time' must be made of whole numbers with no gaps or skips",
.subclass = "error_bad_spacetimedata")
}
space_uniq_val <- sort(unique(df$id_space))
if (!identical(space_uniq_val, seq(min(df$id_space), max(df$id_space), by = 1))) {
stop_subclass("The column 'id_space' must be made of whole numbers with no gaps or skips",
.subclass = "error_bad_spacetimedata")
}
return(invisible(df))
}
devtools::load_all(".")
devtools::load_all(".")
window_idtime(spacetime_data, min_train = 5, n_predict = 1)
set.seed(54515529)
x = rnorm(100)
spacetime_data <- data.frame(id_space = rep(1:10, each = 10),
id_time = rep(1:10, 10),
x = x,
y = 2.04 * x + 1.23)
window_idtime(spacetime_data, min_train = 5, n_predict = 1)
window_idtime(spacetime_data, min_train = 5, n_predict = 1, model_arity = "multi")
devtools::load_all(".")
window_idtime(spacetime_data, min_train = 5, n_predict = 1, model_arity = "multi")
devtools::load_all(".")
window_idtime(spacetime_data, min_train = 5, n_predict = 1, model_arity = "multi")
time_uniq_val
time_uniq_val
seq(min(df$id_time), max(df$id_time), by = 1)
identical(time_uniq_val, seq(min(df$id_time), max(df$id_time), by = 1))
?identical
all.equal(time_uniq_val, seq(min(df$id_time), max(df$id_time), by = 1))
devtools::load_all(".")
window_idtime(spacetime_data, min_train = 5, n_predict = 1, model_arity = "multi")
devtools::load_all(".")
window_idtime(spacetime_data, min_train = 5, n_predict = 1, model_arity = "multi")
windowed_df <- window_idtime(spacetime_data, min_train = 5, n_predict = 1, model_arity = "multi")
test_that("When we window, filter out the data that's not complete", {
mt <- 5
n <- 1
windowed_df <- window_idtime(spacetime_data, min_train = mt, n_predict = n, model_arity = "multi")
expect_equal(min(windowed_df$id_time), mt + n)
})
# mt <- sample(spacetime_data$id_time)
mt <- 10
windowed_df <- window_idtime(spacetime_data, min_train = mt, n_predict = n, model_arity = "multi")
n <- 1
windowed_df <- window_idtime(spacetime_data, min_train = mt, n_predict = n, model_arity = "multi")
# mt <- sample(spacetime_data$id_time)
mt <- 15
windowed_df <- window_idtime(spacetime_data, min_train = mt, n_predict = n, model_arity = "multi")
devtools::load_all(".")
windowed_df <- window_idtime(spacetime_data, min_train = mt, n_predict = n, model_arity = "multi")
devtools::load_all(".")
windowed_df <- window_idtime(spacetime_data, min_train = mt, n_predict = n, model_arity = "multi")
test_that("When we window, filter out the data that's not complete", {
for (ii in 1:100) {
n <- sample(1:5)
mt <- sample(1:(10 - n))
windowed_df <- window_idtime(spacetime_data, min_train = mt, n_predict = n, model_arity = "multi")
expect_equal(min(windowed_df$id_time), mt + n)
}
})
1:(10 - n)
test_that("When we window, filter out the data that's not complete", {
for (ii in 1:100) {
n <- sample(1:5, size = 1)
mt <- sample(1:(10 - n), size = 1)
windowed_df <- window_idtime(spacetime_data, min_train = mt, n_predict = n, model_arity = "multi")
expect_equal(min(windowed_df$id_time), mt + n)
}
})
mt
n <- sample(1:5, size = 1)
for (ii in 1:100) {
n <- sample(1:5, size = 1)
mt <- sample(1:(10 - n), size = 1)
windowed_df <- window_idtime(spacetime_data, min_train = mt, n_predict = n, model_arity = "multi")
expect_equal(min(windowed_df$id_time), mt + n)
}
n
mt
test_that("When we window, filter out the data that's not complete", {
for (ii in 1:100) {
n <- sample(1:5, size = 1)
mt <- sample(1:(10 - n), size = 1)
windowed_df <- window_idtime(spacetime_data, min_train = mt, n_predict = n, model_arity = "multi")
expect_equal(min(windowed_df$id_time), mt + n)
}
})
devtools::load_all(".")
test_that("When we window, filter out the data that's not complete", {
for (ii in 1:100) {
n <- sample(1:5, size = 1)
mt <- sample(1:(10 - n), size = 1)
windowed_df <- window_idtime(spacetime_data, min_train = mt, n_predict = n, model_arity = "multi")
expect_equal(min(windowed_df$id_time), mt + n)
}
})
3 %in# 3
3 %in% 3
# Need to check behavoir for model_arity = "uni"
# Need to check on some weird column types maybe? I guess it's worth check that curr_data is
# always identical to a filtered version of spacetime_data
%has%
