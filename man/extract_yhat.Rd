% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/extract_yhat.R
\name{extract_yhat}
\alias{extract_yhat}
\alias{extract_yhat.merMod}
\alias{extract_yhat.inla}
\title{Extract fitted values from a model object}
\usage{
extract_yhat(fit, newdata, ...)

\method{extract_yhat}{merMod}(fit, newdata, ...)

\method{extract_yhat}{inla}(fit, newdata, se_fit = FALSE, ...)
}
\arguments{
\item{fit}{A model fit object, such as that generated by \code{\link[stats]{`lm`}} or
\code{\link[stats]{glm}}.}

\item{newdata}{A data frame containing the data that should be used to predict the fitted values.
Must have all of the covariates used by the model fit object to calculate fitted values.}

\item{...}{Additional arguments passed into other methods}

\item{se_fit}{If TRUE, also calculate the standard errors of the fitted values. Not available for
all methods.}
}
\value{
The input data frame \code{newdata} with the added column \code{.fitted} containing the predicted
values. If \code{se_fit = TRUE}, then the data frame also contains the column \code{.se.fit} with the
errors of the predicted values. Some models may also return additional columns, such as
\code{.resid}. All columns added by \code{extract_yhat} or \code{augment} start with a dot.
}
\description{
A consistent method for extracting fitted values from a model fit object. Generally
a wrapper around \code{\link[generics]{augment}} from the broom package, but one that always
returns the values on the scale of the response variable. \code{extract_yhat} also covers \code{arima}
and \code{INLA} models that \code{augment} does not. \code{extract_yhat} is a generic, meaning that the method
invoked depends on what type of model is passed as the first argument.
}
\details{
Where possible, \code{extract_yhat} passes its arguments to \code{\link[generics]{augment}},
calling \code{augment(x = fit, newdata = newdata, type.predict = "response")}. In some cases, such
as for \code{\link[lme]{glmer}} models, \code{extract_yhat} takes additional steps to better handle
\code{NA} values in the original dataset used to fit the model. \code{extract_yhat} can also extract
fitted values from arima models or models from the \code{INLA} package that do not have \code{augment}
methods. See below for details on each individual method.
}
\section{Method Details}{

\itemize{
\item{\strong{\code{lm, glm:}} Identical to \code{augment(x = fit, newdata = newdata, type.predict = "response")}}
\item{\strong{\code{lmer, glmer:}} Starts by calling \code{augment}, but removes the columns ".mu",
".offset", ".sqrtXwt", ".sqrtrwt", ".weights", ".wtres", ".gam", and ".eta" from the result.
This is because these columns aren't necessary for statistical surveillance, and because they
have errors when the original data frame contains NA's. In addition, \code{extract_yhat} gives an
error if offset is included as an option in glmer. As a workaround, offsets can be specified
as a term in the model formula, via \code{offset(VAR)}}
\item{\strong{\code{INLA:}} Uses the linear predictor calculated by INLA and the link function
to calculated fitted values. The model must be fit with the option
\code{control.predictor=list(compute = TRUE)} in order for \code{extract_yhat} to work. Can be called
with the option \code{se_fit = TRUE}, which gives standard errors for the fitted values, but note
that this can be extremely slow.}
\item{\strong{Arima models:} See \code{\link{extract_yhat.Arima}} }
}
}

\examples{
library("scanstatistics")
data(NM_popcas)

# Fit a model to all the data, and then extract predictions:
fit <- glm(count ~ year,
           family = poisson(link = "log"),
           offset = log(population),
           data = NM_popcas[1:600, ])

# Then use extract_yhat to get out predictions for our observed variable:
extract_yhat(fit, NM_popcas, se_fit = TRUE)

# We can also fit glmer models
fit_glmer <- lme4::glmer(count ~ I(year - 1980) + (1 | county) + offset(log(population)),
                         family = "poisson",
                         data = NM_popcas[1:600, ])
extract_yhat(fit_glmer, NM_popcas, se_fit = TRUE)

\dontrun{
  # We can also use INLA models if available:
  # All the data points to generate predictions for much be included in the
  # data arg of the INLA model
  fit_inla <- INLA::inla(count ~ year + f(county, model = "iid"),
                         family = "poisson",
                         control.family = list(link = "log"),
                         offset = log(population),
                         # This option is required to use extract_yhat
                         control.predictor = list(compute = TRUE),
                         data = NM_popcas)

  extract_yhat(fit_inla, NM_popcas)
}
}
\seealso{
\code{\link{extract_yhat.Arima}} \code{\link[broom]{augment.lm}}
}
