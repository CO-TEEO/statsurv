NM_county_sf <- NM_county_sf %>%
st_simplify(preserveTopology = TRUE, dTolerance = 10) %>%
st_make_valid()
lobstr::obj_size(z)
tm_shape(NM_county_sf) +
tm_borders() +
tm_shape(z) +
tm_borders("blue")
usethis::use_data(NM_county_sf, overwrite = TRUE)
?NM_popcas
?spacetime_data
NM_data
nrow(NM_data)
range(NM_data$county)
map_dfc(NM_data, function(x) sort(x)[c(1, 608]))])
map_dfc(NM_data, function(x) sort(x)[c(1, 608)])
data("presidents_df")
?presidents
presidents_df
head(presidents_df)
range(presidents_df$approval_rating)
range(presidents_df$approval_rating, na.rm=TRUE)
devtools::document()
?presidents_df
devtools::document()
?presidents_df
?NM_data
?NM_county_sf
?validate_spacetime_data
devtools::document()
?validate_spacetime_data
devtools::document()
?validate_spacetime_data
valid_data <- data.frame(id_space = c(1, 2, 1, 2),
id_time = c(1, 1, 2, 2),
y = c(0.4, 0.5, 0.7, 0.8))
validate_spacetime_data(valid_data)
invalid_data <- data.frame(id_space = c(1, 2.5, 1, 2.5),
id_time = c(1, 1, 2, 2),
y = c(-1, -2, -0.5, -8))
#Gives an error
validate_spacetime_data(invalid_data)
devtools::document()
?validate_spacetime_data
devtools::load_all(".")
?scanstatistics
?statsurv
?scanstatistics
devtools::document()
devtools::document()
devtools::document()
?statsurv
devtools::document()
?statsurv
library(statsurv)
library(statsurv)
library(tidyverse)
itdepends::dep_usage_pkg("ggplot2") %>%
count(pkg, sort = TRUE)
install.packages("itdepends")
usethis::use_package("here", type = "suggests")
usethis::use_package("purrr")
?`:::`
?augment
?predict.Arima
?everything
?predict
?model.frame
?gen_resp
set.seed(986561351)
x = rnorm(100)
spacetime_data <- data.frame(id_space = rep(1:10, each = 10),
id_time = rep(1:10, 10),
x = x,
y = 2.04 * x + 1.23)
check_surv <- function(surv_dfs, base, .id_time) {
check_entry <- function(x, base) {
expect_equal(dplyr::filter(x, id_time == .id_time),
dplyr::filter(base, id_time == .id_time))
}
purrr::walk(surv_dfs, check_entry, base = base)
}
check_lengths <- function(surv_dfs, lengths) {
expect_equal(purrr::map_dbl(surv_dfs, nrow),
lengths)
}
base_df <- window_idtime(spacetime_data, min_train = 5, max_train = 8, n_predict = 1,
split_spatial_locations = FALSE) %>%
rowmute(aug_data = dplyr::mutate(curr_data, .fitted = rnorm(dplyr::n())))
surv_df <- base_df %>%
dplyr::mutate(surv_data = calculate_surveillance_residuals(aug_data,
window_time_id, split_id,
include_init = FALSE,
grow_length = FALSE))
devtools::load_all(".")
surv_df <- base_df %>%
dplyr::mutate(surv_data = calculate_surveillance_residuals(aug_data,
window_time_id, split_id,
include_init = FALSE,
grow_length = FALSE))
devtools::load_all(".")
surv_df <- base_df %>%
dplyr::mutate(surv_data = calculate_surveillance_residuals(aug_data,
window_time_id, split_id,
include_init = FALSE,
grow_length = FALSE))
devtools::load_all(".")
devtools::load_all(".")
surv_df <- base_df %>%
dplyr::mutate(surv_data = calculate_surveillance_residuals(aug_data,
window_time_id, split_id,
include_init = FALSE,
grow_length = FALSE))
working_df <- working_df %>%
rowmute(surveillance_data = dplyr::filter(.data$working_data,
id_time >= {{.data$split_id}}))
devtools::load_all(".")
working_df <- working_df %>%
rowmute(surveillance_data = dplyr::filter(.data$working_data,
id_time >= {{.data$split_id}}))
surv_df <- base_df %>%
dplyr::mutate(surv_data = calculate_surveillance_residuals(aug_data,
window_time_id, split_id,
include_init = FALSE,
grow_length = FALSE))
devtools::load_all(".")
surv_df <- base_df %>%
dplyr::mutate(surv_data = calculate_surveillance_residuals(aug_data,
window_time_id, split_id,
include_init = FALSE,
grow_length = FALSE))
devtools::load_all(".")
surv_df <- base_df %>%
dplyr::mutate(surv_data = calculate_surveillance_residuals(aug_data,
window_time_id, split_id,
include_init = FALSE,
grow_length = FALSE))
devtools::load_all(".")
surv_df <- base_df %>%
dplyr::mutate(surv_data = calculate_surveillance_residuals(aug_data,
window_time_id, split_id,
include_init = FALSE,
grow_length = FALSE))
?expr
?mutate
devtools::document()
devtools::document()
?parallel_cusum_poisson
?prepare_training_data
?arima
?scan_eb_zip
?window_idtime
?extract_yhat
LakeHuron_df
presidents_df
usethis::use_package("ggplot2", type = "suggests")
devtools::document()
devtools::document()
?devtools::run_examples()
devtools::run_examples()
devtools::run_examples()
devtools::run_examples()
devtools::run_examples()
testthat::skip_on_cran
?on_cran
testthat:::on_cran
library("magrritr")
library("magritr")
library("maggritr")
devtools::run_examples()
?collapse
devtools::run_examples()
?devtools::run_examples
devtools::run_examples(start = "collapse.R")
devtools::run_examples(start = "collapse.Rd")
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
?collapse
scanstatistics:::mc_pvalue
scanstatistics:::gumbel_pvalue
pad_spacetime_data(invalid_data)
invalid_data <- data.frame(id_space = c(1, 2),
id_time = c(1, 3),
y = c(1, 3))
pad_spacetime_data(invalid_data)
devtools::document()
?pad_spacetime_data
devtools::document()
?pad_spacetime_data
devtools::document()
?pad_spacetime_data
usethis::use_test()
test_that("Gives an error on mal-formed inputs", {
bad_data <- data.frame(id_space = c(1, 2, 3),
y = c("a", "b", "c"))
expect_error(bad_data, "id_time")
bad_data <- data.frame(id_time = c(1, 2, 3),
y = c("a", "b", "c"))
expect_error(bad_data, "id_space")
bad_data <- data.frame(x = c(1, 2, 3),
y = c("a", "b", "c"))
expect_error(bad_data, "id_space")
})
test_that("Gives an error on mal-formed inputs", {
bad_data <- data.frame(id_space = c(1, 2, 3),
y = c("a", "b", "c"))
expect_error(pad_spacetime_data(bad_data), "id_time")
bad_data <- data.frame(id_time = c(1, 2, 3),
y = c("a", "b", "c"))
expect_error(pad_spacetime_data(bad_data), "id_space")
bad_data <- data.frame(x = c(1, 2, 3),
y = c("a", "b", "c"))
expect_error(pad_spacetime_data(bad_data), "id_space")
})
test_that("Gives an error on mal-formed inputs", {
bad_data <- data.frame(id_space = c(1, 2, 3),
y = c("a", "b", "c"))
expect_error(pad_spacetime_data(bad_data), "id_time")
bad_data <- data.frame(id_time = c(1, 2, 3),
y = c("a", "b", "c"))
expect_error(pad_spacetime_data(bad_data), "id_space")
bad_data <- data.frame(x = c(1, 2, 3),
y = c("a", "b", "c"))
expect_error(pad_spacetime_data(bad_data), "id_space")
bad_data <- data.frame(id_space = c(1, 2, 3),
id_time = c(1.4, 2.1, 3),
y = c("a", "b", "c"))
expect_error(pad_spacetime_data(bad_data), "id_time")
bad_data <- data.frame(id_time = c(1, 2, 3),
id_space = c(1.4, 2.1, 3),
y = c("a", "b", "c"))
expect_error(pad_spacetime_data(bad_data), "id_space")
})
test_that("Doesn't give an error on skips", {
ok_data <- data.frame(id_time = c(1, 3, 4),
id_space = c(1, 2, 3),
y = c("a", "b", "c"))
expect_error(pad_spacetime_data(ok_data), NA)
})
test_that("Doesn't give an error on skips", {
ok_data <- data.frame(id_time = c(1, 3, 4),
id_space = c(1, 2, 3),
y = c("a", "b", "c"))
expect_error(pad_spacetime_data(ok_data), NA)
ok_data <- data.frame(id_time = c(1, 3, 4),
id_space = c(1, 9, 3),
y = c("a", "b", "c"))
expect_error(pad_spacetime_data(ok_data), NA)
})
expand.grid(id_space = 1:3, id_time = 1:3)
expected_combos <- list(c(1, 1), c(1, 2), c(1, 3), c(2, 1), c(2, 2), c(2, 3), c(3, 1), c(3, 2), c(3, 3))
ok_data <- data.frame(id_space = c(1, 3),
id_time = c(1, 2, 3),
y = c("a", "b", "c"))
ok_data <- data.frame(id_space = c(1, 3, 3),
id_time = c(1, 2, 3),
y = c("a", "b", "c"))
pad_spacetime_data(ok_date)
pad_spacetime_data(ok_data)
pad_spacetime_data(ok_data)[, c("id_space", "id_time")]
pad_spacetime_data(ok_data)[, c("id_space", "id_time")] %>%
purrr::transpose()
pad_spacetime_data(ok_data)[, c("id_space", "id_time")] %>%
as.list()
pad_spacetime_data(ok_data)[, c("id_space", "id_time")] %>%
purrr::transpose() %>% purrr::map(unlist)
pad_spacetime_data(ok_data)[, c("id_space", "id_time")] %>%
purrr::transpose() %>% purrr::map(unlist) %>% purrr::map(unname)
test_that("After padding, have all combination of inputs", {
expected_combos <- list(c(1, 1), c(1, 2), c(1, 3), c(2, 1), c(2, 2), c(2, 3), c(3, 1), c(3, 2), c(3, 3))
ok_data <- data.frame(id_space = c(1, 3, 3),
id_time = c(1, 2, 3),
y = c("a", "b", "c"))
check_combos(pad_spacetime_data(ok_data), expected_combos)
})
# Test that...
# 1. we always get a valid frame back after padding
# 2. Throw an error on mal-formed inputs (missing columns, or not integer-ish)
# 3. We pad skips
# 4. We pad missing combinations
# 5. We never remove rows
check_combos <- function(spacetime_data, expected_combos) {
combos <- purrr::transpose(spacetime_data[, c("id_space", "id_time")]) %>%
purrr::map(function(x) unname(unlist(x)))
expect_equal(sort(combos), sort(expected_combos))
expect_error(validate_spacetime_data(spacetime_data), NA)
}
test_that("After padding, have all combination of inputs", {
expected_combos <- list(c(1, 1), c(1, 2), c(1, 3), c(2, 1), c(2, 2), c(2, 3), c(3, 1), c(3, 2), c(3, 3))
ok_data <- data.frame(id_space = c(1, 3, 3),
id_time = c(1, 2, 3),
y = c("a", "b", "c"))
check_combos(pad_spacetime_data(ok_data), expected_combos)
})
?sort
# Test that...
# 1. we always get a valid frame back after padding
# 2. Throw an error on mal-formed inputs (missing columns, or not integer-ish)
# 3. We pad skips
# 4. We pad missing combinations
# 5. We never remove rows
check_combos <- function(spacetime_data, expected_combos) {
combos <- purrr::transpose(spacetime_data[, c("id_space", "id_time")]) %>%
purrr::map(function(x) unname(unlist(x)))
expect_equal(sort.list(combos), sort.list(expected_combos))
expect_error(validate_spacetime_data(spacetime_data), NA)
}
test_that("After padding, have all combination of inputs", {
expected_combos <- list(c(1, 1), c(1, 2), c(1, 3), c(2, 1), c(2, 2), c(2, 3), c(3, 1), c(3, 2), c(3, 3))
ok_data <- data.frame(id_space = c(1, 3, 3),
id_time = c(1, 2, 3),
y = c("a", "b", "c"))
check_combos(pad_spacetime_data(ok_data), expected_combos)
})
# Test that...
# 1. we always get a valid frame back after padding
# 2. Throw an error on mal-formed inputs (missing columns, or not integer-ish)
# 3. We pad skips
# 4. We pad missing combinations
# 5. We never remove rows
check_combos <- function(spacetime_data, expected_combos) {
combos <- purrr::transpose(spacetime_data[, c("id_space", "id_time")]) %>%
purrr::map(function(x) unname(unlist(x)))
browser()
expect_equal(sort.list(combos), sort.list(expected_combos))
expect_error(validate_spacetime_data(spacetime_data), NA)
}
expected_combos <- list(c(1, 1), c(1, 2), c(1, 3), c(2, 1), c(2, 2), c(2, 3), c(3, 1), c(3, 2), c(3, 3))
ok_data <- data.frame(id_space = c(1, 3, 3),
id_time = c(1, 2, 3),
y = c("a", "b", "c"))
check_combos(pad_spacetime_data(ok_data), expected_combos)
combos
sort.list(combos)
sort.list(combos, method = "radix")
do.call(order, combos)
combos
do.call(order, expected_combos)
expected_combos <- expand.grid(id_time = 1:3,
id_space = 1:3)
expected_combos
order(expected_combos)
do.call(order, expected_combos)
ok_data <- data.frame(id_space = c(1, 3),
id_time = c(1, 3),
y = c("a", "b", "c"))
ok_data <- data.frame(id_space = c(1, 3),
id_time = c(1, 3),
y = c("a", "b"))
check_combos(pad_spacetime_data(ok_data), expected_combos)
# Test that...
# 1. we always get a valid frame back after padding
# 2. Throw an error on mal-formed inputs (missing columns, or not integer-ish)
# 3. We pad skips
# 4. We pad missing combinations
# 5. We never remove rows
check_combos <- function(spacetime_data, expected_combos) {
combos <- spacetime_data[, c("id_space", "id_time")] %>%
dplyr::arrange(id_space, id_time)
expected_combos <- expected_combos[, c("id_space", "id_time")] %>%
dplyr::arrange(id_space, id_time)
expect_equal(combos, expected_combos)
expect_error(validate_spacetime_data(spacetime_data), NA)
}
test_that("After padding, have all combination of inputs", {
expected_combos <- expand.grid(id_time = 1:3,
id_space = 1:3)
ok_data <- data.frame(id_space = c(1, 3, 3),
id_time = c(1, 2, 3),
y = c("a", "b", "c"))
check_combos(pad_spacetime_data(ok_data), expected_combos)
ok_data <- data.frame(id_space = c(1, 3),
id_time = c(1, 3),
y = c("a", "b"))
check_combos(pad_spacetime_data(ok_data), expected_combos)
})
test_that("After padding, have all combination of inputs", {
expected_combos <- expand.grid(id_time = 1:3,
id_space = 1:3)
ok_data <- data.frame(id_space = c(1, 3, 3),
id_time = c(1, 2, 3),
y = c("a", "b", "c"))
check_combos(pad_spacetime_data(ok_data), expected_combos)
ok_data <- data.frame(id_space = c(1, 3),
id_time = c(1, 3),
y = c("a", "b"))
check_combos(pad_spacetime_data(ok_data), expected_combos)
ok_data <- data.frame(id_space = c(1, 2, 3, 1, 2, 3),
id_time = c(1, 1, 1, 2, 2, 3),
y = runif(6))
check_combos(pad_spacetime_data(ok_data), expected_combos)
})
test_that("We don't remove rows", {
ok_data <- data.frame(id_space = c(1, 1, 1),
id_time = c(1, 2, 2),
y = c("a", "b", "c"))
expect_equal(ok_data, pad_spacetime_data(ok_data))
})
ok_data <- data.frame(id_space = c(1, 1, 1, 1),
id_time = c(1, 2, 2, 4),
y = c("a", "b", "c", "d"))
pad_spacetime_data(ok_data)
test_that("We don't remove rows", {
ok_data <- data.frame(id_space = c(1, 1, 1),
id_time = c(1, 2, 2),
y = c("a", "b", "c"))
expect_equal(ok_data, pad_spacetime_data(ok_data))
ok_data <- data.frame(id_space = c(1, 1, 1, 1),
id_time = c(1, 2, 2, 4),
y = c("a", "b", "c", "d"))
expected <- data.frame(id_space = 1, id_time = c(1, 2, 2, 3, 4))
check_combos(pad_spacetime_data(ok_data), expected)
})
test_that("We don't remove rows", {
ok_data <- data.frame(id_space = c(1, 1, 1),
id_time = c(1, 2, 2),
y = c("a", "b", "c"))
expect_equal(ok_data, pad_spacetime_data(ok_data))
ok_data <- data.frame(id_space = c(1, 1, 1, 1),
id_time = c(1, 2, 2, 4),
y = c("a", "b", "c", "d"))
expected <- data.frame(id_space = 1, id_time = c(1, 2, 2, 3, 4))
check_combos(pad_spacetime_data(ok_data), expected)
})
devtools::load_all(".")
test_that("We don't remove rows", {
ok_data <- data.frame(id_space = c(1, 1, 1),
id_time = c(1, 2, 2),
y = c("a", "b", "c"))
expect_equal(ok_data, pad_spacetime_data(ok_data))
ok_data <- data.frame(id_space = c(1, 1, 1, 1),
id_time = c(1, 2, 2, 4),
y = c("a", "b", "c", "d"))
expected <- data.frame(id_space = 1, id_time = c(1, 2, 2, 3, 4))
check_combos(pad_spacetime_data(ok_data), expected)
})
?rlang::abort
devtools::load_all(".")
devtools::load_all(".")
?pad_spacetime_data
?gum_fit
?gum.fit
?ismev
?var
?pgumbel
usethis::use_package("ismev")
usethis::use_package("reliaR")
library(here)
score_cusum <- function(y, lambda, scaling) {
# Applied to a purely temporal process
drift <- lambda * (scaling - 1) / log(scaling)
p <- 0
all_p <- rep(NA, length(y))
for (ind in seq_along(y)) {
p <- max(0, p + y[[ind]] - drift[[ind]])
all_p[[ind]] <- p
}
return(all_p)
}
clean_up_v2 <- function(scanres2) {
m2 <- pivot_for_scan(scanres2, .action_level)
dimnames(m2) <- list(NULL, NULL)
m2
}
test_that("parallel_cusum_poisson runs", {
expect_error(parallel_cusum_poisson(wide_cases_lg, wide_baseline_lg),
NA)
})
source(here("tests", "testthat", "setup-alarm_function_data.R"))
test_that("parallel_cusum_poisson runs", {
expect_error(parallel_cusum_poisson(wide_cases_lg, wide_baseline_lg),
NA)
})
test_that("parallel_cusum_poisson gives the scores we expect", {
scanres <- parallel_cusum_poisson(wide_cases_sm, wide_baseline_sm, scaling = 1.5)
scanres2 <- parallel_cusum_poisson2(spacetime_data_sm, cases, .fitted, scaling = 1.5)
scores1 <- score_cusum(wide_cases_sm[, 1],
wide_baseline_sm[, 1],
scaling = 1.5)
scores2 <- score_cusum(wide_cases_sm[, 2],
wide_baseline_sm[, 2],
scaling = 1.5)
expect_equal(scanres[, 1],
scores1)
expect_equal(scanres[, 2],
scores2)
expect_equal(dplyr::filter(scanres2, id_space == 1)$.action_level, scores1)
expect_equal(dplyr::filter(scanres2, id_space == 2)$.action_level, scores2)
})
devtools::load_all(".")
scanres2 <- parallel_cusum_poisson2(spacetime_data_sm, cases, .fitted, scaling = 1.5)
devtools::load_all(".")
scanres2 <- parallel_cusum_poisson2(spacetime_data_sm, cases, .fitted, scaling = 1.5)
params <- dplyr::transmute(spacetime_data,
is_space = .data$id_space,
id_time = .data$id_time,
.scaling = {{scaling}})
params
wide_scaling <- pivot_for_scan(params, .data$.scaling)
devtools::load_all(".")
devtools::load_all(".")
testthat::test_file("tests/testthat/test-pivot_for_scan.R")
devtools::load_all(".")
testthat::test_file("tests/testthat/test-pivot_for_scan.R")
testthat::test_file("tests/testthat/test-pivot_for_scan.R")
testthat::test_file("tests/testthat/test-windowing_functions.R")
devtools::load_all(".")
testthat::test_file("tests/testthat/test-windowing_functions.R")
Sys.getenv("R_QPDF", "qpdf")
