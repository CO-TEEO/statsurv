#' @title Apply an alarm function to the output of `loop_model` and `loop_extract_yhat`
#'
#' @description Given a set of observations and a set of baseline predictions, apply an alarm
#'   function sequentially in time.
#'
#' @param space_coord A gridcoord object
#'   (\code{\link[gridcoord]{gc_gridcoord}}) describing the spatial area that is
#'   covered by `list_of_yhats` and `list_of_model_data`
#' @param time_coord A gridcoord object (\code{\link[gridcoord]{gc_gridcoord}})
#'   describing the temporal area that is covered by `list_of_yhats` and `list_of_model_data`. This
#'   coordinate must be ordered, with the first entries in the coordinate corresponding to the
#'   earliest time periods and the last entries corresponding to the most recent.
#' @param list_of_yhats Either a list or a \link[gridcoord]{gridlist} generated by
#'   \code{\link{loop_extract_yhat}}. Each entry of the list must be a data.frame with columns
#'   corresponding to `space_coord`, `time_coord`, and one or more columns of predicted values.
#'   These entries must either be in a single list organized by time, or a
#'   \link[gridcoord]{gridlist} organized by both space and time.
#' @param list_of_model_data Either a list or a \link[gridcoord]{gridlist}, generated by
#'   \code{\link{loop_model}}. Each entry of `list_of_model_data` must be a data.frame with columns
#'   corresponding to `space_coord`, `time_coord`, and a column containing the primary outcome of
#'   interest. These entries must either be in a single list organized by time, or a
#'   \link[gridcoord]{gridlist} organized by both space and time.
#' @param outcome_col The name of the column in the data.frames in \code{list_of_model_data}
#'   containing the primary outcome (e.g., the number of elevated cases).
#' @param max_k The maximum number of locations to be included in any one zone when constructing
#'   spatial zones for scan-type alarm functions,
#' @param extra_alarm_args A named list containing additional parameters to supply to the
#'   alarm function. Consult the documentation for the individual alarm functions for details.
#' @param use_cache Should the results from this function be saved (cached), so that the results can
#'   be quickly loaded without having to re-run the calculation? Likely only to save time when
#'   applying a scan-type alarm function and both `max_k` and `n_mcsim` are large.
#' @inheritParams loop_extract_yhat
#' @inheritParams standardized_alarm_functions
#'
#' @details `loop_alarm_function` repeatedly applies an alarm function to a set of observations and
#'   baseline predictions. The alarm function cannot be supplied by the user, and must be one of the
#'   functions built into \code{\link{standardized_alarm_functions}}.
#'
#' All of the supported alarm functions support observations in multiple spatial and temporal
#' regions. If either `list_of_yhats` or `list_of_model_data` are
#' \link[gridcoord:gridlist]{gridlists}, they will be collapsed down to a single list organized by
#' time before applying the alarm function.
#'
#' Parallel-type alarms functions, such as \code{\link{parallel_cusum_poisson}} consider each
#' spatial region independently, and calculate 1 alarm statistic for each region. Scan-type alarm
#' functions, such as \code{\link[scanstatistics]{scan_eb_poisson}} aggregate spatial regions into
#' *zones*, and calculate an alarm statistic for each zone. The creation of zones from spatial
#' regions is done using a k-nearest neighbors approach. This means that zones are constructed by
#' starting with each region individually, and sequentially adding its first-nearest-neighbor, then
#' its second-nearest neighbor, and so on up to a maximum size of `max_k`.
#'
#' @inheritSection standardized_alarm_functions Supported Alarm Functions
#' @inheritSection loop_model Caching overview
#'
#' @section Using `loop_alarm_function` with \code{\link{loop_model}} and \code{\link{loop_extract_yhat}}:
#'   `loop_alarm_function` is designed to used in conjunction with \code{\link{loop_model}} and
#'   \code{\link{loop_extract_yhat}}. The coordinate arguments, `space_coord` and `time_coord`
#'   should be identical to those used by the other two functions. `list_of_model_data` should be
#'   generated by  \code{\link{loop_model}}, and `list_of_yhats` should be generated by
#'   \code{\link{loop_extract_yhat}}.  `path_to_model` is optional for `loop_alarm_function`, but to
#'   most clearly organize the cached information, it should match the value used in the other two
#'   functions.
#'
#' @family looping functions
#' @seealso \code{\link{standardized_alarm_functions}} for more information about the available
#'   alarm functions; \code{\link{space_coord_to_zones}} for generating zones manually.
#' @return A list organized by time, where each entry is the result from the individual alarm
#'   function. For the alarm functions that begin "parallel_", each entry is a matrix where the
#'   columns correspond to spatial region and rows correspond to time period; for all other alarm
#'   functions entries are objects of class `scanstatistics`. All results have an attribute
#'   "alarm_type" describing whether they are a scan-type alarm function or a parallel-type alarm
#'   function.
#'
#'   All returned `scanstatistics` objects have been slightly standardized:
#'   \itemize{
#'       \item{The returned object now contains the component `zone_info` containing information
#'       about the spatio-temporal zones}
#'       \item{The returned object always contains the component `observed`, giving the likelihood
#'       of an outbreak in each spatio-temporal zone}
#'       \item{The components `observe`, `MLC`, and `replicates` (if applicable) always contain the
#'       column `action_level`. The higher the value of this column, the greater the likelihood of
#'       an outbreak. This column is identical to `score` for all scan-type alarm functions except
#'       for \code{\link[scanstatistics]{scan_bayes_negbin}}, where it is equal to `log_posterior`}
#'   }
#' @export
#' @md
#'
#' @examples
#' library("scanstatistics")
#' library("magrittr")
#' library("gridcoord")
#' data(NM_popcas)
#' NM_popcas$county <- as.character(NM_popcas$county)
#' NM_popcas$date_label <- as.character(NM_popcas$year)
#'
#' nm_county_fips_2010 <- statsurv::nm_county_fips_2010
#' nm_county_fips_2010$county <- gsub(" ", "", tolower(nm_county_fips_2010$county_name))
#' nm_county_fips_2010 <- nm_county_fips_2010[nm_county_fips_2010$county != "cibola", ]
#' nm_county_fips_2010 <- gc_gridcoord(nm_county_fips_2010, "county")
#'
#' year_coord <- generate_date_range(lubridate::ymd("1973-01-01"),
#'                                   lubridate::ymd("1991-01-01"),
#'                                   time_division = "year")
#'
#' glm_func <- function(space_coord, time_coord, data_for_model) {
#'   mod <- glm(count ~ year,
#'              family = poisson(link = "log"),
#'              offset = log(population),
#'              data = data_for_model)
#'   return(list(fit = mod,
#'               data = data_for_model))
#' }
#'
#' fits_and_data <- loop_model(nm_county_fips_2010, year_coord, NM_popcas,
#'                             outcome_col = "count",
#'                             path_to_model = glm_func)
#' all_fits <- fits_and_data[[1]]
#' all_data <- fits_and_data[[2]]
#'
#' all_yhats <- loop_extract_yhat(nm_county_fips_2010, year_coord, all_fits, all_data,
#'                                yhat_extractor_name = "extract",
#'                                use_surveillance_residuals = FALSE)
#'
#'
#' # Finally, crate alarm statistics
#' # A scan-type alarm:
#' all_alarms <- loop_alarm_function(nm_county_fips_2010, year_coord, all_yhats, all_data,
#'                                   outcome_col = "count",
#'                                   alarm_function_name = "scan_eb_poisson",
#'                                   max_k = 3,
#'                                   n_mcsim = 10)
#'
#' all_alarms <- loop_alarm_function(nm_county_fips_2010, year_coord, all_yhats, all_data,
#'                                   outcome_col = "count",
#'                                   alarm_function_name = "scan_bayes_negbin",
#'                                   max_k = 3)
#'
#'
#' # Or a parallel-type alarm:
#' all_alarms <- loop_alarm_function(nm_county_fips_2010, year_coord, all_yhats, all_data,
#'                                   outcome_col = "count",
#'                                   alarm_function_name = "parallel_cusum_poisson",
#'                                   extra_alarm_args = list(scaling = 1.25))
loop_alarm_function <- function(space_coord,
                                time_coord,
                                list_of_yhats,
                                list_of_model_data,
                                outcome_col,
                                alarm_function_name,
                                max_k,
                                n_mcsim = 10,
                                use_cache = FALSE, #Arguments for caching
                                path_to_model = NULL,
                                force = FALSE,
                                verbose = interactive(),
                                extra_alarm_args = list()) {

  ### Combine the data spatially, if split ----
  list_of_yhats <- collapse_if_exploded(space_coord, time_coord, list_of_yhats)
  list_of_model_data <- collapse_if_exploded(space_coord, time_coord, list_of_model_data)
  extra_alarm_args <- lapply(extra_alarm_args,
                            collapse_if_exploded,
                            space_coord = space_coord,
                            time_coord = time_coord)


  ### Argument checks ----
  space_coord <- gridcoord::gc_gridcoord(space_coord)
  time_coord <- gridcoord::gc_gridcoord(time_coord)
  check_type(list_of_yhats, "list")
  check_type(list_of_model_data, "list")
  check_scalar_type(outcome_col, "character")
  check_scalar_type(alarm_function_name, "character")
  check_scalar_type(use_cache, "logical")
  check_type(path_to_model, c("NULL", "character", "function"))
  if (is.character(path_to_model)) {
    check_scalar(path_to_model)
  }
  # force passed through to the cache
  check_scalar_type(verbose, "logical")

  ### Prep steps for scan-type alarms functions ----
  zones <- NULL
  key_matrix <- NULL
  alarm_type <- calculate_alarm_type(alarm_function_name)
  if (alarm_type == "scan") {
    check_scalar_type(max_k, "integer")
    if (max_k < 0) {
      stop("max_k must be greater than 0")
    } else if (max_k > nrow(space_coord)) {
      stop("max_k must be less than the number of spatial areas")
    }

    if (!is_type(space_coord, c("Spatial", "sf"))) {
      stop("In order to use a scan-type alarm function, 'space_coord' must be a ",
           "spatialPolygonsDataFrame or an sf-type data.frame")
    }
    zones <- space_coord_to_zones(space_coord, max_k = max_k)
    key_matrix <- build_key_matrix(zones)
  }


  ### Computation steps: ----
  ### ~~~1. Step up caching ----
  cache_dir <- calc_cache_dir(use_cache,
                              top_level = "cache_alarm",
                              ifelse(is.character(path_to_model),
                                     path_to_model,
                                     deparse(substitute(path_to_model))),
                              alarm_function_name,
                              max_k)


  cached_standardized_alarm_mc <- suppressWarnings(
    simplecache::cache_wrap(standardized_alarm_multicol,
                            cache_dir,
                            hash_in_name = FALSE,
                            save_environments = TRUE))
  force <- parse_force(force, time_coord)


  ### ~~~2. Pad extra_alarm_args ----
  n_iter <- sum(!is_singular_na(list_of_yhats))
  list_args <- pad_args(extra_alarm_args,
                        reference = list_of_yhats)

  ### ~~~3. Loop through all the model fits ----
  all_scan_res <- list()
  progress_bar <- dot_progress_functional(n_iter, 1, 5,
                                          title = "Calculating scan statistics",
                                          verbose = verbose)
  for (ind in seq_along(list_of_model_data)) {
    ### ~~~4. Calculate scan statistics, collapse yhat columns if necessary ----
    curr_label <- names(list_of_model_data)[[ind]]
    tall_counts <- list_of_model_data[[ind]]
    long_yhat <- list_of_yhats[[ind]]
    if (identical(long_yhat, NA)) {
      next
    }
    wide_counts <- pivot_for_scan(tall_counts, outcome_col, space_coord, time_coord)

    cache_name <- build_cache_name(curr_label, space_coord)

    scan_res <- do.call.with.dots(cached_standardized_alarm_mc,
                                  space_coord = space_coord,
                                  time_coord = time_coord,
                                  alarm_function_name = alarm_function_name,
                                  wide_cases = wide_counts,
                                  zone_info = zones,
                                  long_yhat = long_yhat,
                                  n_mcsim = n_mcsim,
                                  # zones = zones,
                                  # key_matrix = key_matrix,
                                  list_of_args = list_args[[ind]],
                                  .name_prefix = cache_name,
                                  .force = force[[ind]])

    ### ~~~5. Accumulate Results ----
    all_scan_res[[curr_label]] <- scan_res
    progress_bar()
  }

  padded_scan_res <- pad_with_nas(all_scan_res, coord = time_coord)
  return(padded_scan_res) #zones are now included as part of the scan result, if applicable
}

