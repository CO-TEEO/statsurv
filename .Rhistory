fit <- INLA::inla(formulas[[curr_row$f_name]],
data = ey_data,
family = curr_row$family,
control.family = list(link = curr_row$link),
control.compute = list(config = TRUE),
control.predictor = list(compute=TRUE),
offset = offset)
yhat <- extract_yhat(fit, ey_newdata)
} else {
fit <- INLA::inla(formulas[[curr_row$f_name]],
data = ey_data,
family = curr_row$family,
control.family = list(link = curr_row$link),
control.compute = list(config = TRUE),
control.predictor = list(compute=TRUE))
yhat <- extract_yhat(fit, ey_newdata)
}
check_extract(fit, yhat, formulas[[curr_row$f_name]])
}
ind
curr_row
f <- formulas[[curr_row$f_name]]
f
# We need some way to check that our fitted values are actually reasonable.
# We compare the means and also the range of values
y <- yhat %>%
dplyr::select(!!f[[2]]) %>%
.[[1]]
m1 <- mean(y)
m2 <- mean(yhat$.fitted)
d <- (m1-m2)/m2
d
f[[2]]
as.character(f[[2]])
grepl("qpois", as.character(f[[2]]))
source('~/r-analysis/statsurv/tests/testthat/setup-extract_yhat.R')
curr_row
yhat <- extract_yhat(fit, ey_newdata)
check_extract(fit, yhat, formulas[[curr_row$f_name]])
nrow(glm_combos)
for (ind in seq_len(nrow(glm_combos))) {
curr_row <- inla_combos[ind, , drop = FALSE]
if (curr_row$offset) {
fit <- INLA::inla(formulas[[curr_row$f_name]],
data = ey_data,
family = curr_row$family,
control.family = list(link = curr_row$link),
control.compute = list(config = TRUE),
control.predictor = list(compute=TRUE),
offset = offset)
yhat <- extract_yhat(fit, ey_newdata)
} else {
fit <- INLA::inla(formulas[[curr_row$f_name]],
data = ey_data,
family = curr_row$family,
control.family = list(link = curr_row$link),
control.compute = list(config = TRUE),
control.predictor = list(compute=TRUE))
yhat <- extract_yhat(fit, ey_newdata)
}
check_extract(fit, yhat, formulas[[curr_row$f_name]])
}
curr_row
inla_combos
ind <- 16
curr_row <- inla_combos[ind, , drop = FALSE]
fit <- INLA::inla(formulas[[curr_row$f_name]],
data = ey_data,
family = curr_row$family,
control.family = list(link = curr_row$link),
control.compute = list(config = TRUE),
control.predictor = list(compute=TRUE),
offset = offset)
yhat <- extract_yhat(fit, ey_newdata)
fit2 <- INLA::inla(formulas[[curr_row$f_name]],
data = ey_data,
family = curr_row$family,
control.family = list(link = curr_row$link),
control.compute = list(config = TRUE),
control.predictor = list(compute=TRUE),
E = exposure)
yhat2 <- extract_yhat(fit2, ey_newdata)
waldo::compare(yhat, yhat2)
?expect_equal
expect_equal(yhat, yhat2, tolerance = 0.01)
for (ind in seq_len(nrow(glm_combos))) {
curr_row <- inla_combos[ind, , drop = FALSE]
if (curr_row$offset) {
fit <- INLA::inla(formulas[[curr_row$f_name]],
data = ey_data,
family = curr_row$family,
control.family = list(link = curr_row$link),
control.compute = list(config = TRUE),
control.predictor = list(compute=TRUE),
offset = offset)
yhat <- extract_yhat(fit, ey_newdata)
fit2 <- INLA::inla(formulas[[curr_row$f_name]],
data = ey_data,
family = curr_row$family,
control.family = list(link = curr_row$link),
control.compute = list(config = TRUE),
control.predictor = list(compute=TRUE),
E = exposure)
yhat2 <- extract_yhat(fit2, ey_newdata)
expect_equal(yhat, yhat2, tolerance = 0.01)
} else {
fit <- INLA::inla(formulas[[curr_row$f_name]],
data = ey_data,
family = curr_row$family,
control.family = list(link = curr_row$link),
control.compute = list(config = TRUE),
control.predictor = list(compute=TRUE))
yhat <- extract_yhat(fit, ey_newdata)
}
check_extract(fit, yhat, formulas[[curr_row$f_name]])
}
formulas_mermod
?f
formulas_inla2 <- purrr::map(formulas, adj_f_inla)
adj_f_inla <- function(f) {
f[[3]] <- rlang::expr(!!f[[3]] + f(id_space, model = "iid"))
f
}
formulas_inla2 <- purrr::map(formulas, adj_f_inla)
formulas_inla2
?crossing
inla_combos <- dplyr::left_join(glm_combos, inla_lookup, by = "link_name")
inla_combos
expand.grid(inla_combos, which = c(TRUE, FALSE))
expand.grid(df = inla_combos, which = c(TRUE, FALSE)) %>% tibble::as_tibble()
expand.grid(df = inla_combos, which = c(TRUE, FALSE))
inla_combos <- bind_rows(mutate(inla_combos, use_mer = TRUE),
mutate(inla_combos, use_mer = FALSE))
inla_combos <- dplyr::bind_rows(mutate(inla_combos, use_mer = TRUE),
mutate(inla_combos, use_mer = ))
inla_combos <- dplyr::left_join(glm_combos, inla_lookup, by = "link_name")
inla_combos <- dplyr::bind_rows(dplyr::mutate(inla_combos, use_mer = TRUE),
dplyr::mutate(inla_combos, use_mer = ))
inla_combos
formulas_inla <- purrr::map(formulas, adj_f_inla)
inla_lookup <- tibble::tribble(~link_name, ~family, ~link,
"gaussian", "gaussian", "identity",
"logit", "binomial", "logit",
"probit", "binomial", "probit",
"poisson", "poisson", "log",
"quasipoisson", "nbinomial", "log")
inla_combos <- dplyr::left_join(glm_combos, inla_lookup, by = "link_name")
inla_combos <- dplyr::bind_rows(dplyr::mutate(inla_combos, use_mer = TRUE),
dplyr::mutate(inla_combos, use_mer = ))
for (ind in seq_len(nrow(inla_combos))) {
curr_row <- inla_combos[ind, , drop = FALSE]
curr_f <- if (curr_row$use_mer) {
formulas_inla[[curr_row$f_name]]
} else {
formulas[[curr_row$f_name]]
}
if (curr_row$offset) {
fit <- INLA::inla(curr_f,
data = ey_data,
family = curr_row$family,
control.family = list(link = curr_row$link),
control.compute = list(config = TRUE),
control.predictor = list(compute=TRUE),
offset = offset)
yhat <- extract_yhat(fit, ey_newdata)
fit2 <- INLA::inla(curr_f,
data = ey_data,
family = curr_row$family,
control.family = list(link = curr_row$link),
control.compute = list(config = TRUE),
control.predictor = list(compute=TRUE),
E = exposure)
yhat2 <- extract_yhat(fit2, ey_newdata)
expect_equal(yhat, yhat2, tolerance = 0.01)
} else {
fit <- INLA::inla(curr_f,
data = ey_data,
family = curr_row$family,
control.family = list(link = curr_row$link),
control.compute = list(config = TRUE),
control.predictor = list(compute=TRUE))
yhat <- extract_yhat(fit, ey_newdata)
}
check_extract(fit, yhat, curr_f)
}
curr_f
ind
fit <- INLA::inla(curr_f,
data = ey_data,
family = curr_row$family,
control.family = list(link = curr_row$link),
control.compute = list(config = TRUE),
control.predictor = list(compute=TRUE))
fit <- INLA::inla(curr_f,
data = ey_data,
family = curr_row$family,
control.family = list(link = curr_row$link),
control.compute = list(config = TRUE),
control.predictor = list(compute=TRUE), verbose = TRUE)
curr_f
ind
ind <- 3
curr_row <- inla_combos[ind, , drop = FALSE]
curr_f <- if (curr_row$use_mer) {
formulas_inla[[curr_row$f_name]]
} else {
formulas[[curr_row$f_name]]
}
if (curr_row$offset) {
fit <- INLA::inla(curr_f,
data = ey_data,
family = curr_row$family,
control.family = list(link = curr_row$link),
control.compute = list(config = TRUE),
control.predictor = list(compute=TRUE),
offset = offset)
yhat <- extract_yhat(fit, ey_newdata)
fit2 <- INLA::inla(curr_f,
data = ey_data,
family = curr_row$family,
control.family = list(link = curr_row$link),
control.compute = list(config = TRUE),
control.predictor = list(compute=TRUE),
E = exposure)
yhat2 <- extract_yhat(fit2, ey_newdata)
expect_equal(yhat, yhat2, tolerance = 0.01)
} else {
fit <- INLA::inla(curr_f,
data = ey_data,
family = curr_row$family,
control.family = list(link = curr_row$link),
control.compute = list(config = TRUE),
control.predictor = list(compute=TRUE), verbose = TRUE)
yhat <- extract_yhat(fit, ey_newdata)
}
for (ind in seq_len(nrow(inla_combos))) {
print(ind)
curr_row <- inla_combos[ind, , drop = FALSE]
curr_f <- if (curr_row$use_mer) {
formulas_inla[[curr_row$f_name]]
} else {
formulas[[curr_row$f_name]]
}
if (curr_row$offset) {
fit <- INLA::inla(curr_f,
data = ey_data,
family = curr_row$family,
control.family = list(link = curr_row$link),
control.compute = list(config = TRUE),
control.predictor = list(compute=TRUE),
offset = offset)
yhat <- extract_yhat(fit, ey_newdata)
fit2 <- INLA::inla(curr_f,
data = ey_data,
family = curr_row$family,
control.family = list(link = curr_row$link),
control.compute = list(config = TRUE),
control.predictor = list(compute=TRUE),
E = exposure)
yhat2 <- extract_yhat(fit2, ey_newdata)
expect_equal(yhat, yhat2, tolerance = 0.01)
} else {
fit <- INLA::inla(curr_f,
data = ey_data,
family = curr_row$family,
control.family = list(link = curr_row$link),
control.compute = list(config = TRUE),
control.predictor = list(compute=TRUE), verbose = FALSE)
yhat <- extract_yhat(fit, ey_newdata)
}
check_extract(fit, yhat, curr_f)
}
for (ind in seq_len(nrow(inla_combos))) {
print(ind)
if (ind %in% c(2)) {
next
}
curr_row <- inla_combos[ind, , drop = FALSE]
curr_f <- if (curr_row$use_mer) {
formulas_inla[[curr_row$f_name]]
} else {
formulas[[curr_row$f_name]]
}
if (curr_row$offset) {
fit <- INLA::inla(curr_f,
data = ey_data,
family = curr_row$family,
control.family = list(link = curr_row$link),
control.compute = list(config = TRUE),
control.predictor = list(compute=TRUE),
offset = offset)
yhat <- extract_yhat(fit, ey_newdata)
fit2 <- INLA::inla(curr_f,
data = ey_data,
family = curr_row$family,
control.family = list(link = curr_row$link),
control.compute = list(config = TRUE),
control.predictor = list(compute=TRUE),
E = exposure)
yhat2 <- extract_yhat(fit2, ey_newdata)
expect_equal(yhat, yhat2, tolerance = 0.01)
} else {
fit <- INLA::inla(curr_f,
data = ey_data,
family = curr_row$family,
control.family = list(link = curr_row$link),
control.compute = list(config = TRUE),
control.predictor = list(compute=TRUE), verbose = FALSE)
yhat <- extract_yhat(fit, ey_newdata)
}
check_extract(fit, yhat, curr_f)
}
for (ind in seq_len(nrow(inla_combos))) {
if (ind %in% c(2, 8)) {
next
}
print(ind)
curr_row <- inla_combos[ind, , drop = FALSE]
curr_f <- if (curr_row$use_mer) {
formulas_inla[[curr_row$f_name]]
} else {
formulas[[curr_row$f_name]]
}
if (curr_row$offset) {
fit <- INLA::inla(curr_f,
data = ey_data,
family = curr_row$family,
control.family = list(link = curr_row$link),
control.compute = list(config = TRUE),
control.predictor = list(compute=TRUE),
offset = offset)
yhat <- extract_yhat(fit, ey_newdata)
fit2 <- INLA::inla(curr_f,
data = ey_data,
family = curr_row$family,
control.family = list(link = curr_row$link),
control.compute = list(config = TRUE),
control.predictor = list(compute=TRUE),
E = exposure)
yhat2 <- extract_yhat(fit2, ey_newdata)
expect_equal(yhat, yhat2, tolerance = 0.01)
} else {
fit <- INLA::inla(curr_f,
data = ey_data,
family = curr_row$family,
control.family = list(link = curr_row$link),
control.compute = list(config = TRUE),
control.predictor = list(compute=TRUE), verbose = FALSE)
yhat <- extract_yhat(fit, ey_newdata)
}
check_extract(fit, yhat, curr_f)
}
curr_f
f <- curr_f
# We need some way to check that our fitted values are actually reasonable.
# We compare the means and also the range of values
y <- yhat %>%
dplyr::select(!!f[[2]]) %>%
.[[1]]
m1 <- mean(y)
m2 <- mean(yhat$.fitted)
d <- (m1-m2)/m2
d
check_extract <- function(fit, yhat, f) {
expect_true(".fitted" %in% colnames(yhat))
expect_true(is.data.frame(yhat))
# We need some way to check that our fitted values are actually reasonable.
# We compare the means and also the range of values
y <- yhat %>%
dplyr::select(!!f[[2]]) %>%
.[[1]]
m1 <- mean(y)
m2 <- mean(yhat$.fitted)
d <- (m1-m2)/m2
if (!"-" %in% as.character(f[[3]]))  {
# Often get large disagreements if no intercept, which I don't understand but OK.
if ("negbin" %in% class(fit) || grepl("qpois", as.character(f[[2]]))) {
# Also get larger disagreemetns for glm.nb
expect_true(abs(d) <= 0.04)
} else {
expect_true(abs(d) < 0.02)
}
}
# Then check that the domains are correct
fitted <- yhat$.fitted
if (all(y <= 1) & all(y >= 0)) {
expect_true(all(fitted >= 0) & all(fitted <= 1))
}
if (all(y > 0)) {
expect_true(all(fitted > 0))
}
}
for (ind in seq_len(nrow(inla_combos))) {
if (ind %in% c(2, 8)) {
next
}
print(ind)
curr_row <- inla_combos[ind, , drop = FALSE]
curr_f <- if (curr_row$use_mer) {
formulas_inla[[curr_row$f_name]]
} else {
formulas[[curr_row$f_name]]
}
if (curr_row$offset) {
fit <- INLA::inla(curr_f,
data = ey_data,
family = curr_row$family,
control.family = list(link = curr_row$link),
control.compute = list(config = TRUE),
control.predictor = list(compute=TRUE),
offset = offset)
yhat <- extract_yhat(fit, ey_newdata)
fit2 <- INLA::inla(curr_f,
data = ey_data,
family = curr_row$family,
control.family = list(link = curr_row$link),
control.compute = list(config = TRUE),
control.predictor = list(compute=TRUE),
E = exposure)
yhat2 <- extract_yhat(fit2, ey_newdata)
expect_equal(yhat, yhat2, tolerance = 0.01)
} else {
fit <- INLA::inla(curr_f,
data = ey_data,
family = curr_row$family,
control.family = list(link = curr_row$link),
control.compute = list(config = TRUE),
control.predictor = list(compute=TRUE), verbose = FALSE)
yhat <- extract_yhat(fit, ey_newdata)
}
check_extract(fit, yhat, curr_f)
}
devtools::load_all(".")
inla_combos <- dplyr::left_join(glm_combos, inla_lookup, by = "link_name")
inla_combos <- dplyr::bind_rows(dplyr::mutate(inla_combos, use_mer = TRUE),
dplyr::mutate(inla_combos, use_mer = FALSE))
for (ind in seq_len(nrow(inla_combos))) {
# if (ind %in% c(2, 8)) {
#   next
# }
print(ind)
curr_row <- inla_combos[ind, , drop = FALSE]
if (curr_row$use_mer) {
curr_f <- formulas_inla[[curr_row$f_name]]
curr_data <- ey_data_mermod
curr_newdata <- ey_newdata_mermod
} else {
curr_f <- formulas[[curr_row$f_name]]
curr_data <- ey_data
curr_newdata <- ey_newdata
}
if (curr_row$offset) {
fit <- INLA::inla(curr_f,
data = curr_data,
family = curr_row$family,
control.family = list(link = curr_row$link),
control.compute = list(config = TRUE),
control.predictor = list(compute=TRUE),
offset = offset)
yhat <- extract_yhat(fit, curr_newdata)
fit2 <- INLA::inla(curr_f,
data = curr_data,
family = curr_row$family,
control.family = list(link = curr_row$link),
control.compute = list(config = TRUE),
control.predictor = list(compute=TRUE),
E = exposure)
yhat2 <- extract_yhat(fit2, curr_newdata)
expect_equal(yhat, yhat2, tolerance = 0.01)
} else {
fit <- INLA::inla(curr_f,
data = curr_data,
family = curr_row$family,
control.family = list(link = curr_row$link),
control.compute = list(config = TRUE),
control.predictor = list(compute=TRUE), verbose = FALSE)
yhat <- extract_yhat(fit, curr_newdata)
}
check_extract(fit, yhat, curr_f)
}
### Extra things to check for INLA ----
# We get a nice error message if we don't use control.compute / control. predictor
test_that("extract_yhat.INLA gives a useful error if control.predictor$compute = FALSE", {
if (!inla_available) skip("INLA not available")
bad_fit_inla <- INLA::inla(formulas$f_lm,
data = ey_data,
family = "gaussian",
control.compute = list(config = TRUE),
control.predictor = list(compute = FALSE))
# Currently gives an error, but not a useful one.
expect_error(extract_yhat(ey_space, ey_time, bad_fit_inla, ey_data),
"control.predictor")
expect_warning(sample_yhat(ey_space, ey_time, bad_fit_inla, ey_data, n_samples = 10),
"control.predictor")
})
bad_fit_inla <- INLA::inla(formulas$f_lm,
data = ey_data,
family = "gaussian",
control.compute = list(config = TRUE),
control.predictor = list(compute = FALSE))
# Currently gives an error, but not a useful one.
expect_error(extract_yhat(ey_space, ey_time, bad_fit_inla, ey_data),
"control.predictor")
?extract_yhat
extract_yhat(bad_fit_inla, ey_newdatadata)
# Currently gives an error, but not a useful one.
expect_error(extract_yhat(bad_fit_inla, ey_newdatadata),
"control.predictor")
devtools::document()
?extract_yhat.Arima
devtools::document()
?extract_yhat.Arima
